<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="爱生活、爱技术、积极、乐观、超越自我">
<meta property="og:type" content="website">
<meta property="og:title" content="谢晖的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="谢晖的博客">
<meta property="og:description" content="爱生活、爱技术、积极、乐观、超越自我">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="谢晖的博客">
<meta name="twitter:description" content="爱生活、爱技术、积极、乐观、超越自我">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":true,"scrollpercent":true},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> 谢晖的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    
      <div class="site-meta-headline">
        <a>
          <img class="custom-logo-image" src="/images/me.jpg"
               alt="谢晖的博客"/>
        </a>
      </div>
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">谢晖的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">爱生活、爱技术、积极、乐观、超越自我</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/26/为什么你应该切换从Svn到Git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谢晖">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谢晖的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/26/为什么你应该切换从Svn到Git/" itemprop="url">
                  为什么你应该切换从Svn到Git
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-26T22:26:05+08:00">
                2017-04-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/26/为什么你应该切换从Svn到Git/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/26/为什么你应该切换从Svn到Git/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h1><p>Git是一款免费、开源的目前世界上最先进的分布式版本控制系统（没有之一），用于敏捷高效地处理任何或小或大的项目， Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<h1 id="Git的诞生"><a href="#Git的诞生" class="headerlink" title="Git的诞生"></a>Git的诞生</h1><p>很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。</p>
<p>Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？</p>
<p>事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！</p>
<p>你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。</p>
<p>不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。</p>
<p>安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。</p>
<p>Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：</p>
<p>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。</p>
<p>Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p>
<p>历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。</p>
<h1 id="集中式vs分布式"><a href="#集中式vs分布式" class="headerlink" title="集中式vs分布式"></a>集中式vs分布式</h1><p>Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？</p>
<p>先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p>
<p><img src="http://www.liaoxuefeng.com/files/attachments/001384860735706fd4c70aa2ce24b45a8ade85109b0222b000/0" alt="集中式"></p>
<p>集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。</p>
<p>那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p>
<p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>
<p><img src="http://www.liaoxuefeng.com/files/attachments/0013848607465969378d7e6d5e6452d8161cf472f835523000/0" alt="分布式"></p>
<p>当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。</p>
<p>CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。</p>
<p>除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。</p>
<p>微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。</p>
<p>分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！</p>
<h1 id="轻量级分支：无摩擦上下文切换"><a href="#轻量级分支：无摩擦上下文切换" class="headerlink" title="轻量级分支：无摩擦上下文切换"></a>轻量级分支：无摩擦上下文切换</h1><p>在我开始解释这之前，这实际上是我最喜欢的Git功能，我需要你帮我一个忙。忘记你对分支机构的了解。您对Subversion中“分支”意味着什么的知识是有毒的，特别是如果您在1.5之前内部化，就像我一样，在Subversion终于增加了一些基本的合并跟踪功能之前。忘记合并多么痛苦，忘记切换分支花费多长时间，忘记从不同一个分支合并的可能性–Git在分支和合并方面给你一个全新的世界。</p>
<p>在Git中，分支机构不是一个肮脏的词汇 - 它们经常被使用并经常合并，在许多情况下，开发人员将为每个功能创建一个功能，并且每天可以将它们合并在一起，并且通常是无痛的。这是Git首先吸引我的，实际上改变了我对我发展的整个方式。</p>
<p>当您在Git中创建分支时，它会在本地进行，并且发生得非常快。以下是创建一个分支，然后切换到新分支以开始开发的示例。</p>
<h1 id="拉请求-Pull-Requests"><a href="#拉请求-Pull-Requests" class="headerlink" title="拉请求(Pull Requests)"></a>拉请求(Pull Requests)</h1><p>许多源代码管理工具，比如Bitbucket，可以通过拉请求来增强核心的Git功能。 拉请求是要求另一开发人员将您的一个分支合并到其存储库中的一种方式。 这不仅使项目潜在客户能够更轻松地跟踪变更情况，还可以让开发人员在将其与其他代码集成在一起之前展开工作。</p>
<p>由于它们本质上是附加到要素分支的注释线程，所以拉请求是非常通用的。 当开发者遇到困难的问题时，他们可以打开一个拉动请求，要求其他团队的帮助。 或者，初级开发人员可以相信，他们不会通过将拉请求视为正式代码审查来破坏整个项目。</p>
<p>Reference：  <a href="http://blog.teamtreehouse.com/why-you-should-switch-from-subversion-to-git" target="_blank" rel="external">why you should switch from subversion to git</a>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/17/分布式一致性协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谢晖">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谢晖的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/17/分布式一致性协议/" itemprop="url">
                  分布式一致性协议
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-17T22:11:02+08:00">
                2017-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/17/分布式一致性协议/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/17/分布式一致性协议/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h1><p>为了解决分布式一致性问题，在长期的探索研究的过程中，涌现出了一大批经典的一致性协议和算法，其中最著名的就是二阶段、三阶段提交协议和Paxos算法。</p>
<h2 id="2PC与3PC"><a href="#2PC与3PC" class="headerlink" title="2PC与3PC"></a>2PC与3PC</h2><p>在分布式系统中，每一个机器节点虽然都能明确的知道自己执行的事务是成功还是失败，但是却无法知道其他分布式节点的事务执行情况。因此，当一个事务要跨越多个分布式节点的时候（比如，淘宝下单流程，下单系统和库存系统可能就是分别部署在不同的分布式节点中），为了保证该事务可以满足ACID，就要引入一个协调者（Cooradinator）。其他的节点被称为参与者（Participant）。协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务进行提交。</p>
<h2 id="2PC（Two-Phase-Commitment-Protocol）"><a href="#2PC（Two-Phase-Commitment-Protocol）" class="headerlink" title="2PC（Two Phase Commitment Protocol）"></a>2PC（Two Phase Commitment Protocol）</h2><p>2PC，是 Two-phase commit的缩写，即二阶段提交，是计算机网络尤其是在数据库领域内，为了使基于分布式系统架构下的所有节点在进行事物处理过程中能够保持原子性和一致性而设计的一种算法。通常，二阶段提交协议也被认为是一种一致性协议，用来保证分布式系统数据的一致性。目前，绝大部分关系型数据库都是采用二阶段提交协议来完成分布式事务处理的，利用该协议能够非常方便的完成所有分布式参与者的协调，统一决定事物的提交或回滚，从而能够有效的保证分布式数据一致性，因此二阶段提交协议被广泛的应用在许多分布式系统中。</p>
<h3 id="协议说明"><a href="#协议说明" class="headerlink" title="协议说明"></a>协议说明</h3><ol>
<li><p><strong>(第一阶段)提交请求阶段:</strong></p>
<ul>
<li><p>协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。</p>
</li>
<li><p>参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）</p>
</li>
<li><p>各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</p>
</li>
</ul>
</li>
<li><strong>(第二阶段)提交执行阶段:</strong></li>
</ol>
<p>　　当协调者节点从所有参与者节点获得的相应消息都为”同意”时：
　　</p>
<ul>
<li><p>协调者节点向所有参与者节点发出”正式提交(commit)”的请求。</p>
</li>
<li><p>参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</p>
</li>
<li><p>参与者节点向协调者节点发送”完成”消息。</p>
</li>
<li><p>协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。</p>
</li>
</ul>
<p>　　<em>如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：</em></p>
<ul>
<li><p>协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。</p>
</li>
<li><p>参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</p>
</li>
<li><p>参与者节点向协调者节点发送”回滚完成”消息。</p>
</li>
<li><p>协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</p>
</li>
</ul>
<p>　　不管最后结果如何，第二阶段都会结束当前事务。</p>
<p><img src="https://access.redhat.com/documentation/en-US/JBoss_Enterprise_Application_Platform/5/html/Transactions_Development_Guide/images/fig-two-phase-commit-overview.png" alt="2pc"></p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>　　1、执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</p>
<p>　　2、参与者发生故障。协调者需要给每个参与者额外指定超时机制，超时后整个事务失败。（没有多少容错机制）</p>
<p>　　3、协调者发生故障。参与者会一直阻塞下去。需要额外的备机进行容错。</p>
<p>　　4、二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p>
<h2 id="3PC（Three-phase-commit-protocol）"><a href="#3PC（Three-phase-commit-protocol）" class="headerlink" title="3PC（Three-phase commit protocol）"></a>3PC（Three-phase commit protocol）</h2><p>3PC，是 Three-phase commit的缩写，即三阶段提交，是2PC的改进版，其将二阶段的”提交请求阶段”一分为二，形成了由CanCommit,PreCommit和do Commit三个阶段组成的一致性协议。引入超时机制。同时在协调者和参与者中都引入超时机制(如下图)。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/en/3/39/Three-phase_commit_diagram.png" alt="3pc"></p>
<h3 id="协议说明-1"><a href="#协议说明-1" class="headerlink" title="协议说明"></a>协议说明</h3><h4 id="阶段一：CanCommit"><a href="#阶段一：CanCommit" class="headerlink" title="阶段一：CanCommit"></a>阶段一：CanCommit</h4><p>   1．事务询问。</p>
<p>  协调者向所有的参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。</p>
<p>   2．各参与者向协调者反馈事务询问的响应。</p>
<p>  参与者在接收到来自协调者的canCommit请求后，正常情况下，如果其自身认为可以顺利执行事务，那么会反馈Yes响应，并进入预备状态，否则反馈No响应。</p>
<h4 id="阶段二：PreCommit"><a href="#阶段二：PreCommit" class="headerlink" title="阶段二：PreCommit"></a>阶段二：PreCommit</h4><pre><code>在阶段二中，协调者会根据各参与者的反馈情况来决定是否可以进行事务的PreCommit操作，正常情况下，包含两种可能。
</code></pre><p>执行事务预提交</p>
<p>假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务预提交。</p>
<p>1．发送预提交请求。</p>
<p>协调者向所有参与者节点发出preCommit的请求，并进入Prepared阶段。</p>
<p>2．事务预提交。</p>
<p>参与者接收到preCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中。</p>
<p>3．各参与者向协调者反馈事务执行的响应。</p>
<p>如果参与者成功执行了事务操作，那么就会反馈给协调者Ack响应，同时等待最终的指令：提交（commit）或中止（abort）。</p>
<p>中断事务</p>
<p>假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</p>
<p>1．发送中断请求。</p>
<p>协调者向所有参与者节点发出abort请求。</p>
<p>2．中断事务。</p>
<p>无论是收到来自协调者的abort请求，或者是在等待协调者请求过程中出现超时，参与者都会中断事务。</p>
<h4 id="阶段三：doCommit"><a href="#阶段三：doCommit" class="headerlink" title="阶段三：doCommit"></a>阶段三：doCommit</h4><p>该阶段将进行真正的事务提交，会存在以下两种可能的情况。</p>
<p><strong>执行提交</strong></p>
<p>1．发送提交请求。</p>
<p>进入这一阶段，假设协调者处于正常工作状态，并且它接收到了来自所有参与者的Ack响应，那么它将从“预提交”状态转换到“提交”状态，并向所有的参与者发送doCommit请求。</p>
<p>2．事务提交。</p>
<p>参与者接收到doCommit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。</p>
<p>3．反馈事务提交结果。</p>
<p>参与者在完成事务提交之后，向协调者发送Ack消息。</p>
<p>4．完成事务。</p>
<p>协调者接收到所有参与者反馈的Ack消息后，完成事务。</p>
<p><strong>中断事务</strong></p>
<p>进入这一阶段，假设协调者处于正常工作状态，并且有任意一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</p>
<p>1．发送中断请求。</p>
<p>协调者向所有的参与者节点发送abort请求。</p>
<p>2．事务回滚。</p>
<p>参与者接收到abort请求后，会利用其在阶段二中记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。</p>
<p>3．反馈事务回滚结果。</p>
<p>参与者在完成事务回滚之后，向协调者发送Ack消息。</p>
<p>4．中断事务。</p>
<p>协调者接收到所有参与者反馈的Ack消息后，中断事务。</p>
<p><em>需要注意的是，一旦进入阶段三，可能会存在以下两种故障。</em></p>
<ul>
<li><p>协调者出现问题。</p>
</li>
<li><p>协调者和参与者之间的网络出现故障。</p>
</li>
</ul>
<p>无论出现哪种情况，最终都会导致参与者无法及时接收到来自协调者的doCommit或是abort请求，针对这样的异常情况，参与者都会在等待超时之后，继续进行事务提交。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>三阶段提交协议的优点：相较于二阶段提交协议，三阶段提交协议最大的优点就是降低了参与者的阻塞范围，并且能够在出现单点故障后继续达成一致。</p>
<p>三阶段提交协议的缺点：三阶段提交协议在去除阻塞的同时也引入了新的问题，那就是在参与者接收到preCommit消息后，如果网络出现分区，此时协调者所在的节点和参与者无法进行正常的网络通信，在这种情况下，该参与者依然会进行事务的提交，这必然出现数据的不一致性。</p>
<h2 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h2><p> Paxos算法是莱斯利·兰伯特(Leslie Lamport)1990年提出的一种基于消息传递的一致性算法。Paxos算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。在工程实践意义上来说，就是可以通过Paxos实现多副本一致性，分布式锁，名字管理，序列号分配等。比如，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。本文首先会讲原始的Paxos算法(Basic Paxos)，主要描述二阶段提交过程，然后会着重讲Paxos算法的变种(Multi Paxos)，它是对Basic Paxos的优化，而且更适合工程实践，最后我会通过Q&amp;A的方式，给出我在学习Paxos算法中的疑问，以及我对这些疑问的理解。</p>
<h3 id="概念与术语"><a href="#概念与术语" class="headerlink" title="概念与术语"></a>概念与术语</h3><p>Proposer：提议发起者，处理客户端请求，将客户端的请求发送到集群中，以便决定这个值是否可以被批准。</p>
<p>Acceptor：提议批准者，负责处理接收到的提议，他们的回复就是一次投票，会存储一些状态来决定是否接收一个值。</p>
<p>Replica：节点或者副本，分布式系统中的一个server，一般是一台单独的物理机或者虚拟机，同时承担paxos中的提议者和接收者角色。</p>
<p>ProposalId：每个提议都有一个编号，编号高的提议优先级高。</p>
<p>Paxos Instance：Paxos中用来在多个节点之间对同一个值达成一致的过程，比如同一个日志序列号：logIndex，不同的logIndex属于不同的Paxos Instance。</p>
<p>acceptedProposal：在一个Paxos Instance内，已经接收过的提议。</p>
<p>acceptedValue：在一个Paxos Instance内，已经接收过的提议对应的值。</p>
<p>minProposal：在一个Paxos Instance内，当前接收的最小提议值，会不断更新。</p>
<h3 id="Basic-Paxos算法"><a href="#Basic-Paxos算法" class="headerlink" title="Basic-Paxos算法"></a>Basic-Paxos算法</h3><p>基于Paxos协议构建的系统，只需要系统中超过半数的节点在线且相互通信正常即可正常对外提供服务。它的核心实现Paxos Instance主要包括两个阶段:准备阶段(prepare phase)和提议阶段(accept phase)。如下图所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/176539/201606/176539-20160626155541328-1939247065.png" alt="Basic-Paxos"></p>
<ol>
<li>获取一个ProposalId,为了保证ProposalId递增，可以采用时间戳+serverId方式生成；</li>
<li>提议者向所有节点广播prepare(n)请求；</li>
<li>接收者比较n和minProposal，如果n&gt;minProposal,表示有更新的提议，minProposal=n；否则将(acceptedProposal,acceptedValue)返回；</li>
<li>提议者接收到过半数请求后，如果发现有acceptedValue返回，表示有更新的提议，保存acceptedValue到本地，然后跳转1，生成一个更高的提议；</li>
<li>到这里表示在当前paxos instance内，没有优先级更高的提议，可以进入第二阶段，广播accept(n,value)到所有节点；</li>
<li>接收者比较n和minProposal，如果n&gt;=minProposal,则acceptedProposal=minProposal=n，acceptedValue=value，本地持久化后，返回；<br>否则，返回minProposal</li>
<li>提议者接收到过半数请求后，如果发现有返回值&gt;n，表示有更新的提议，跳转1；否则value达成一致。<br>从上述流程可知，并发情况下，可能会出现第4步或者第7步频繁重试的情况，导致性能低下，更严重者可能导致永远都无法达成一致的情况，就是所谓的“活锁”，如下图所示：</li>
</ol>
<p><img src="http://images2015.cnblogs.com/blog/176539/201606/176539-20160626155452844-827453906.png" alt="Basic-Paxos"></p>
<ol>
<li>S1作为提议者，发起prepare(3.1),并在S1,S2和S3达成多数派；</li>
<li>随后S5作为提议者 ，发起了prepare(3.5)，并在S3,S4和S5达成多数派；</li>
<li>S1发起accept(3.1,value1)，由于S3上提议 3.5&gt;3.1,导致accept请求无法达成多数派，S1尝试重新生成提议</li>
<li>S1发起prepare(4.1),并在S1，S2和S3达成多数派</li>
<li>S5发起accpet(3.5,value5)，由于S3上提议4.1&gt;3.5，导致accept请求无法达成多数派，S5尝试重新生成提议</li>
<li>S5发起prepare(5.5),并在S3,S4和S5达成多数派，导致后续的S1发起的accept(4.1,value1)失败<br>……</li>
</ol>
<h3 id="prepare阶段的作用"><a href="#prepare阶段的作用" class="headerlink" title="prepare阶段的作用"></a>prepare阶段的作用</h3><p>从Basic-Paxos的描述可知，需要通过两阶段来最终确定一个值，由于轮回多，导致性能低下，至少两次网络RTT。那么prepare阶段能否省去？如下图所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/176539/201606/176539-20160626155558641-1089133612.png" alt="Basic-Paxos"></p>
<ol>
<li>S1首先发起accept(1,red)，并在S1,S2和S3达成多数派，red在S1，S2，S3上持久化</li>
<li>随后S5发起accept(5,blue)，对于S3而言，由于接收到更新的提议，会将acceptedValue值改为blue</li>
<li>那么S3，S4和S5达成多数派，blue在S3，S4和S5持久化</li>
<li>最后的结果是，S1和S2的值是red，而S3，S4和S5的值是blue，没有达成一致。</li>
</ol>
<p>所以两阶段必不可少，Prepare阶段的作用是阻塞旧的提议，并且返回已经接收到的acceptedProposal。同时也可以看到的是，假设只有S1提议，则不会出现问题，这就是我们下面要讲的Multi-Paxos。</p>
<h3 id="Multi-paxos算法"><a href="#Multi-paxos算法" class="headerlink" title="Multi-paxos算法"></a>Multi-paxos算法</h3><p> Paxos是对一个值达成一致，Multi-Paxos是连续多个paxos instance来对多个值达成一致，这里最核心的原因是multi-paxos协议中有一个Leader。Leader是系统中唯一的Proposal，在lease租约周期内所有提案都有相同的ProposalId，可以跳过prepare阶段，议案只有accept过程，一个ProposalId可以对应多个Value，所以称为Multi-Paxos。</p>
<h4 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h4><p>首先我们需要有一个leader，其实选主的实质也是一次Paxos算法的过程，只不过这次Paxos确定的“谁是leader”这个值。由于任何一个节点都可以发起提议，在并发情况下，可能会出现多主的情况，比如A，B先后当选为leader。为了避免频繁选主，当选leader的节点要马上树立自己的leader权威(让其它节点知道它是leader)，写一条特殊日志(start-working日志)确认其身份。根据多数派原则，只有一个leader的startworking日志可以达成多数派。leader确认身份后，可以通过了lease机制(租约)维持自己的leader身份，使得其它proposal不再发起提案，这样就进入了leader任期，由于没有并发冲突，因此可以跳过prepare阶段，直接进入accept阶段。通过分析可知，选出leader后，leader任期内的所有日志都只需要一个网络RTT(Round Trip Time)即可达成一致。</p>
<h4 id="新主恢复流程"><a href="#新主恢复流程" class="headerlink" title="新主恢复流程"></a>新主恢复流程</h4><p>由于Paxos中并没有限制，任何节点都可以参与选主并最终成为leader，这就无法保证新选出的leader包含了所有日志，可能存在空洞，因此在真正提供服务前，还存在一个获取所有已提交日志的恢复过程。新主向所有成员查询最大logId的请求，收到多数派响应后，选择最大的logId作为日志恢复结束点，这里多数派的意义在于恢复结束点包含了所有达成一致的日志，当然也可能包含了没有达成多数派的日志。拿到logId后，从头开始对每个logId逐条进行paxos协议，因为在新主获得所有日志之前，系统是无法提供服务的。为了优化，引入了confirm机制，就是将已经达成一致的logId告诉其它acceptor，acceptor写一条confirm日志到日志文件中。那么新主在重启后，扫描本地日志，对于已经拥有confirm日志的log，就不会重新发起paxos了。同样的，在响应客户端请求时，对于没有confirm日志的log，需要重新发起一轮paxos。由于没有严格要求confirm日志的位置，可以批量发送。为了确保重启时，不需要对太多已提价的log进行paxos，需要将confirm日志与最新提交的logId保持一定的距离。</p>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>Basic-Paxos一次日志确认，需要至少2次磁盘写操作(prepare,promise)和2次网络RTT(prepare,promise)。Multi-Paxos利用一阶段提交(省去Prepare阶段)，将一次日志确认缩短为一个RTT和一次磁盘写；通过confirm机制，可以缩短新主的恢复时间。为了提高性能，我们还可以实现一批日志作为一个组提交，要么成功一批，要么都不成功，这点类似于group-commit，通过RT换取吞吐量。</p>
<h4 id="安全性-异常处理"><a href="#安全性-异常处理" class="headerlink" title="安全性(异常处理)"></a>安全性(异常处理)</h4><ol>
<li><p>Leader异常<br>Leader在任期内，需要定期给各个节点发送心跳，已告知它还活着(正常工作)，如果一个节点在超时时间内仍然没有收到心跳，它会尝试发起选主流程。Leader异常了，则所有的节点先后都会出现超时，进入选主流程，选出新的主，然后新主进入恢复流程，最后再对外提供服务。我们通常所说的异常包括以下三类：</p>
<ul>
<li><p>进程crash(OS crash)</p>
<p> Leader进程crash和Os crash类似，只要重启时间大于心跳超时时间都会导致节点认为leader挂了，触发重新选主流程。</p>
</li>
<li><p>节点网络异常(节点所在网络分区)</p>
<p> Leader网络异常同样会导致其它节点收不到心跳，但有可能leader是活着的，只不过发生了网络抖动，因此心跳超时不能设置的太短，否则容易因为网络抖动造成频繁选主。另外一种情况是，节点所在的IDC发生了分区，则同一个IDC的节点相互还可以通信，如果IDC中节点能构成多数派，则正常对外服务，如果不能，比如总共4个节点，两个IDC，发生分区后会发现任何一个IDC都无法达成多数派，导致无法选出主的问题。因此一般Paxos节点数都是奇数个，而且在部署节点时，IDC节点的分布也要考虑。</p>
</li>
<li><p>磁盘故障</p>
<p>前面两种异常，磁盘都是OK的，即已接收到的日志以及对应confirm日志都在。如果磁盘故障了，节点再加入就类似于一个新节点，上面没有任何日志和Proposal信息。这种情况会导致一个问题就是，这个节点可能会promise一个比已经promise过的最大proposalID更小的proposal，这就违背了Paxos原则。因此重启后，节点不能参与Paxos Instance，它需要先追上Leader，当观察到一次完整的paxos instance时该节点结束不能promise/ack状态。</p>
</li>
</ul>
</li>
<li><p>Follower异常(宕机，磁盘损坏等)<br>对于Follower异常，则处理要简单的多，因为follower本身不对外提供服务(日志可能不全)，对于leader而言，只要能达成多数派，就可以对外提供服务。follower重启后，没有promise能力，直到追上leader为止。</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/14/docker-介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谢晖">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谢晖的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/14/docker-介绍/" itemprop="url">
                  docker 介绍
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-14T21:41:18+08:00">
                2017-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/14/docker-介绍/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/14/docker-介绍/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Docker-介绍"><a href="#Docker-介绍" class="headerlink" title="Docker 介绍"></a>Docker 介绍</h1><p>如果您是程序员或技术人员，您至少可以听说Docker：一个有用的工具，用于在“容器”中打包，运送和运行应用程序。这很难让所有的注意力得到 这些天 - 从开发人员和系统管理员一样。 即使像Google，VMware和亚马逊这样的大公司也在建设服务来支持它。</p>
<p>Docker是一个新的容器化的技术，它轻巧，且易移植，号称“build once, configure once and run anywhere”。</p>
<p>无论您是否对Docker有进行使用过，我仍然认为了解一些关于“容器”的基本概念以及如何与虚拟机（VM）进行比较是非常重要的。 虽然互联网充满了Docker的优秀使用指南，但我找不到许多初学者友好的概念指南，特别是在容器组成的方面。 所以，希望这篇文章会解决这个问题。</p>
<p>我们先来了解什么VM和容器呢？</p>
<h1 id="什么是“容器”和“虚拟机”？"><a href="#什么是“容器”和“虚拟机”？" class="headerlink" title="什么是“容器”和“虚拟机”？"></a>什么是“容器”和“虚拟机”？</h1><p>容器和虚拟机的目标是相似的：将应用程序及其依赖项隔离成可以在任何地方运行的独立单元。<br>此外，容器和虚拟机不再需要物理硬件，从而在能源消耗和成本效益方面更有效地利用计算资源。<br>容器和虚拟机之间的主要区别在于它们的架构方法。 我们来看看吧。</p>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>虚拟机本质上是一个真正的计算机的仿真，它执行像真正的计算机那样的程序。虚拟机使用“虚拟机监控程序”运行在物理机的顶部。管理程序又可以在主机或“裸机”上运行。<br>我们来解释这个行话：<br>虚拟机管理程序是虚拟机在其上运行的一个软件，固件或硬件。虚拟机管理程序本身运行在物理计算机上，被称为“主机”。主机为VM提供资源，包括RAM和CPU。这些资源在虚拟机之间划分，可以根据您的需要进行分发。因此，如果一个虚拟机正在运行资源较多的应用程序，则可能会为在同一主机上运行的其他虚拟机分配更多的资源。<br>在主机上运行的虚拟机（再次使用虚拟机管理程序）通常也称为“客户机”。此客机包含应用程序以及运行该应用程序所需的任何应用程序（例如系统二进制程序和库）。它还具有自己的整个虚拟化硬件堆栈，包括虚拟化网络适配器，存储和CPU - 这意味着它也有自己的成熟的客户操作系统。从内部，客机作为自己的单位，拥有自己的专属资源。从外面，我们知道这是一个VM - 共享主机提供的资源。</p>
<p>如上所述，客机可以在托管管理程序或裸机管理程序上运行。他们之间有一些重要的区别。<br>首先，托管虚拟化管理程序在主机的操作系统上运行。例如，运行OSX的计算机可以在该OS之上安装VM（例如VirtualBox或VMware Workstation 8）。 VM不能直接访问硬件，所以它必须经过主机操作系统（在我们的例子中是Mac的OSX）。<br>托管管理程序的好处是底层硬件不那么重要。主机的操作系统负责硬件驱动程序而不是管理程序本身，因此被认为具有更多的“硬件兼容性”。另一方面，硬件和管理程序之间的这个附加层会产生更多的资源开销，从而降低虚拟机的性能。<br>裸机管理程序环境通过在主机硬件上安装和运行来解决性能问题。因为它直接与底层硬件接口，所以不需要主机操作系统来运行。在这种情况下，作为操作系统安装在主机服务器上的第一件事就是管理程序。与托管虚拟机管理程序不同，裸机管理程序具有自己的设备驱动程序，并直接与每个组件进行交互，用于任何I / O，处理或特定于操作系统的任务。这导致更好的性能，可扩展性和稳定性。这里的折衷是硬件兼容性受到限制，因为管理程序只能在其中内置许多设备驱动程序。<br>所有这些谈论虚拟机管理程序之后，您可能会想知道为什么我们需要在VM和主机之间的这个额外的“虚拟机管理程序”层。<br>那么，由于虚拟机具有自己的虚拟操作系统，虚拟机管理程序在为虚拟机提供一个管理和执行客户机操作系统的平台方面发挥重要作用。它允许主机计算机在作为其上的客户端运行的虚拟机之间共享其资源。</p>
<p><img src="/images/vm.png" alt="VM"></p>
<p>如图所示，虚拟机将虚拟硬件，内核（即OS）和每个新虚拟机的用户空间进行打包。</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>与提供硬件虚拟化的虚拟机不同，容器通过抽象“用户空间”来提供操作系统级的虚拟化。 当我们解开容器术语时，你会看到我的意思。<br>出于所有目的和目的，容器看起来像一个虚拟机。 例如，它们具有用于处理的私有空间，可以以root身份执行命令，具有专用网络接口和IP地址，允许自定义路由和iptable规则，可以挂载文件系统等。</p>
<p><strong><em>容器和虚拟机之间的一个很大的区别是容器与其他容器共享主机系统的内核。</em></strong></p>
<p><img src="/images/container.png" alt="container"></p>
<p>该图显示了容器仅包含用户空间，而不是像VM那样的内核或虚拟硬件。 每个容器都拥有自己的隔离用户空间，允许多个容器在单个主机上运行。 我们可以看到，所有的操作系统级架构正在容器间共享。 从头创建的唯一部分是bin和libs。 这就是容器如此轻便。</p>
<h1 id="Docker从哪里入手"><a href="#Docker从哪里入手" class="headerlink" title="Docker从哪里入手?"></a>Docker从哪里入手?</h1><p>Docker是一个基于Linux容器的开源项目。 它使用Linux内核功能（如命名空间和控制组）来在操作系统之上创建容器。<br>集装箱距离不远; Google多年来一直在使用自己的集装箱技术。 其他Linux容器技术包括已经存在多年的Solaris Zones，BSD监狱和LXC。</p>
<p>是什么原因让Docker变得如此受欢迎呢？</p>
<ol>
<li>易于使用：Docker使开发人员，系统管理员，架构师和其他人更容易利用容器来快速构建和测试便携式应用程序。它允许任何人在他们的笔记本电脑上打包应用程序，而这些应用程序又可以在任何公共云，私有云甚至裸机上运行。咒语是：“建立一次，在任何地方运行”。</li>
<li>速度：Docker容器非常轻便和快速。由于容器只是在内核上运行的沙盒环境，因此它们占用的资源较少。与可能需要更长时间的VM相比，您可以在几秒钟内创建和运行Docker容器，因为每次都需要启动完整的虚拟操作系统。</li>
<li>Docker Hub：Docker用户也受益于Docker Hub日益丰富的生态系统，您可以将其视为“Docker镜像的应用商店”。Docker Hub拥有成千上万的社区创建的公共图片，可随时获得用来。搜索满足您需求的镜像非常容易，随时可以下拉和使用，无需修改。</li>
<li>模块化和可扩展性：Docker可以轻松地将应用程序的功能分解成单个容器。例如，您的Postgres数据库可能会在一个容器中运行，并且您的Redis服务器在另一个容器中运行，而Node.js应用程序位于另一容器中。使用Docker，将这些容器链接到一起创建应用程序变得更加容易，以便将来可以轻松地自动扩展或更新组件。</li>
</ol>
<h1 id="基本的Docker概念"><a href="#基本的Docker概念" class="headerlink" title="基本的Docker概念"></a>基本的Docker概念</h1><p>现在我们已经有了很大的发展空间，我们先看一下Docker的基本部分：</p>
<p><img src="/images/docker.png" alt="docker"></p>
<h2 id="Docker引擎"><a href="#Docker引擎" class="headerlink" title="Docker引擎"></a>Docker引擎</h2><p>Docker引擎是Docker运行的层。 它是一个轻量级的运行时和工具，用于管理容器，镜像，构建等。 它在Linux系统上本机运行，由以下组成：</p>
<ol>
<li>在主机中运行的Docker守护进程。</li>
<li>一个Docker客户端，然后与Docker守护进程通信以执行命令。</li>
<li>一个用于远程与Docker守护进行交互的REST API。</li>
</ol>
<h2 id="Docker客户端"><a href="#Docker客户端" class="headerlink" title="Docker客户端"></a>Docker客户端</h2><p>Docker客户端是您作为Docker的最终用户进行通信的对象。 认为它是Docker的UI。 例如，当你做</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build iampeekay/someImage .</div></pre></td></tr></table></figure>
<p>您正在与Docker客户端通信，Docker客户端会将您的指令传达给Docker守护进程。</p>
<h2 id="Docker守护进程"><a href="#Docker守护进程" class="headerlink" title="Docker守护进程"></a>Docker守护进程</h2><p>Docker守护程序是实际执行发送到Docker Client的命令，如构建，运行和分发容器。 Docker守护程序在主机上运行，但作为用户，您不会直接与守护进程通信。 Docker客户端也可以在主机上运行，但不需要。 它可以在不同的机器上运行，并与主机上运行的Docker守护程序进行通信。</p>
<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>Dockerfile是您编写构建Docker镜像的说明的地方。 这些说明可以是：</p>
<ul>
<li><strong>RUN apt-get y install some-package:</strong>安装一个软件包;</li>
<li><strong>EXPOSE 8000：</strong> 对外开放端口;</li>
<li><strong>ENV ANT_HOME /usr/local/apache-ant</strong>  传递一个环境变量;<br>等等。<br>一旦设置了Dockerfile，就可以使用docker build命令来构建一个镜像。 以下是Docker文件的示例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"># Start with ubuntu 14.04</div><div class="line">FROM ubuntu:14.04</div><div class="line"></div><div class="line">MAINTAINER preethi kasireddy iam.preethi.k@gmail.com</div><div class="line"></div><div class="line"># For SSH access and port redirection</div><div class="line">ENV ROOTPASSWORD sample</div><div class="line"></div><div class="line"># Turn off prompts during installations</div><div class="line">ENV DEBIAN_FRONTEND noninteractive</div><div class="line">RUN echo &quot;debconf shared/accepted-oracle-license-v1-1 select true&quot; | debconf-set-selections</div><div class="line">RUN echo &quot;debconf shared/accepted-oracle-license-v1-1 seen true&quot; | debconf-set-selections</div><div class="line"></div><div class="line"># Update packages</div><div class="line">RUN apt-get -y update</div><div class="line"></div><div class="line"># Install system tools / libraries</div><div class="line">RUN apt-get -y install python3-software-properties \</div><div class="line">    software-properties-common \</div><div class="line">    bzip2 \</div><div class="line">    ssh \</div><div class="line">    net-tools \</div><div class="line">    vim \</div><div class="line">    curl \</div><div class="line">    expect \</div><div class="line">    git \</div><div class="line">    nano \</div><div class="line">    wget \</div><div class="line">    build-essential \</div><div class="line">    dialog \</div><div class="line">    make \</div><div class="line">    build-essential \</div><div class="line">    checkinstall \</div><div class="line">    bridge-utils \</div><div class="line">    virt-viewer \</div><div class="line">    python-pip \</div><div class="line">    python-setuptools \</div><div class="line">    python-dev</div><div class="line"></div><div class="line"># Install Node, npm</div><div class="line">RUN curl -sL https://deb.nodesource.com/setup_4.x | sudo -E bash -</div><div class="line">RUN apt-get install -y nodejs</div><div class="line"></div><div class="line"># Add oracle-jdk7 to repositories</div><div class="line">RUN add-apt-repository ppa:webupd8team/java</div><div class="line"></div><div class="line"># Make sure the package repository is up to date</div><div class="line">RUN echo &quot;deb http://archive.ubuntu.com/ubuntu precise main universe&quot; &gt; /etc/apt/sources.list</div><div class="line"></div><div class="line"># Update apt</div><div class="line">RUN apt-get -y update</div><div class="line"></div><div class="line"># Install oracle-jdk7</div><div class="line">RUN apt-get -y install oracle-java7-installer</div><div class="line"></div><div class="line"># Export JAVA_HOME variable</div><div class="line">ENV JAVA_HOME /usr/lib/jvm/java-7-oracle</div><div class="line"></div><div class="line"># Run sshd</div><div class="line">RUN apt-get install -y openssh-server</div><div class="line">RUN mkdir /var/run/sshd</div><div class="line">RUN echo &quot;root:$ROOTPASSWORD&quot; | chpasswd</div><div class="line">RUN sed -i &apos;s/PermitRootLogin without-password/PermitRootLogin yes/&apos; /etc/ssh/sshd_config</div><div class="line"></div><div class="line"># SSH login fix. Otherwise user is kicked off after login</div><div class="line">RUN sed &apos;s@session\s*required\s*pam_loginuid.so@session optional pam_loginuid.so@g&apos; -i /etc/pam.d/sshd</div><div class="line"></div><div class="line"># Expose Node.js app port</div><div class="line">EXPOSE 8000</div><div class="line"></div><div class="line"># Create tap-to-android app directory</div><div class="line">RUN mkdir -p /usr/src/my-app</div><div class="line">WORKDIR /usr/src/my-app</div><div class="line"></div><div class="line"># Install app dependencies</div><div class="line">COPY . /usr/src/my-app</div><div class="line">RUN npm install</div><div class="line"></div><div class="line"># Add entrypoint</div><div class="line">ADD entrypoint.sh /entrypoint.sh</div><div class="line">RUN chmod +x /entrypoint.sh</div><div class="line">ENTRYPOINT [&quot;/entrypoint.sh&quot;]</div><div class="line"></div><div class="line">CMD [&quot;npm&quot;, &quot;start&quot;]</div></pre></td></tr></table></figure>
<h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><p>镜像是从您的Dockerfile中写入的一组说明构建的只读模板。 镜像定义了您想要的打包应用程序及其依赖关系，看起来像<em>和</em>启动时要运行的进程。</p>
<p>Docker镜像使用Dockerfile构建。 Dockerfile中的每个指令都为镜像添加了一个新的“镜像层”，其中镜像层表示镜像文件系统的一部分，它们添加到或替换镜像层下面的镜像层。 层是Docker轻巧而强大结构的关键。 Docker使用Union File System来实现：</p>
<h3 id="联合文件系统-Union-File-Systems"><a href="#联合文件系统-Union-File-Systems" class="headerlink" title="联合文件系统(Union File Systems)"></a>联合文件系统(Union File Systems)</h3><p>Docker使用Union File Systems来构建镜像。 您可以将Union File System视为可堆叠文件系统，这意味着单独文件系统（称为分支）的文件和目录可以透明地叠加以形成单个文件系统。</p>
<p>在重叠的分支中具有相同路径的目录的内容被视为单个合并目录，这避免了需要创建每个层的单独副本。 相反，它们都可以被赋予相同资源的指针; 当某些层需要修改时，它会创建一个副本并修改一个本地副本，保留原来的不变。 这就是文件系统如何<em>可以</em>可写，而不实际允许写入。 （换句话说，是一个“写时复制”系统。）</p>
<p>分层系统提供两个主要优点：</p>
<ol>
<li>无复制：每次使用镜像创建和运行新容器时，镜像层有助于避免复制一组完整的文件，从而实现Docker容器的快速便宜。</li>
<li>层隔离：进行更改更快 - 当您更改镜像时，Docker只会将更新传播到已更改的层。</li>
</ol>
<h2 id="卷-Volumes"><a href="#卷-Volumes" class="headerlink" title="卷(Volumes)"></a>卷(Volumes)</h2><p>卷是容器的“数据”部分，在容器创建时初始化。 卷允许您持久存储并共享容器的数据。 数据卷与默认的Union File System分开，并且作为主机文件系统上的普通目录和文件存在。 因此，即使您销毁，更新或重建容器，数据卷将保持不变。 当您要更新卷时，您可以直接对其进行更改。 （另外，数据量可以在多个容器之间共享和重复使用，这是非常整齐的。）</p>
<h2 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h2><p>如上所述，Docker容器将应用程序的软件包装到与应用程序需要运行的所有内容的不可见框中。 这包括操作系统，应用程序代码，运行时，系统工具，系统库等。Docker容器是由Docker镜像构建的。 由于镜像是只读的，Docker在镜像的只读文件系统上添加了一个读写文件系统来创建一个容器。</p>
<p><img src="/images/docker2.png" alt="docker"></p>
<p>此外，然后创建容器，Docker创建一个网络接口，以便容器可以与本地主机通信，将可用的IP地址附加到容器，并在定义镜像时执行您指定运行应用程序的进程。<br>成功创建容器后，可以在任何环境中运行它，而无需进行更改。</p>
<h2 id="Docker支柱"><a href="#Docker支柱" class="headerlink" title="Docker支柱"></a>Docker支柱</h2><p>总是让我好奇的一件事是容器如何实际实现，特别是因为容器周围没有任何抽象的基础设施边界。 经过很多阅读，这一切都很有意义，所以这里是我尝试向你解释的！ :</p>
<p>术语“<strong>容器</strong>”实际上只是一个抽象的概念来描述几个不同的特征如何协同工作来可视化“容器”。 让我们快速过一过这些知识点：</p>
<p>1 <strong>命名空间(Namespaces)</strong></p>
<p>命名空间为容器提供了自己对底层Linux系统的视图，限制了容器可以看到和访问的内容。运行容器时，Docker创建特定容器将使用的命名空间。</p>
<p>Docker使用的内核中有几种不同类型的命名空间，例如：</p>
<ul>
<li>NET：提供具有自己的系统网络堆栈视图（例如其自己的网络设备，IP地址，IP路由表，/ proc / net目录，端口号等）的容器。</li>
<li>PID：PID代表进程ID。如果您在命令行中运行过ps aux以检查系统上正在运行哪些进程，那么您将看到一个名为“PID”的列。 PID命名空间给容器提供他们可以查看和交互的进程的自己的范围视图，包括一个独立的init（PID 1），它是“所有进程的祖先”。</li>
<li>MNT：给系统自己的“mounts”视图的容器。因此，不同安装名称空间中的进程对文件系统层次结构具有不同的视图。</li>
<li>UTS：UTS代表UNIX分时系统。它允许进程识别系统标识符（即主机名，域名等）。 UTS允许容器具有与其他容器和主机系统无关的自己的主机名和NIS域名。</li>
<li>IPC：IPC代表InterProcess Communication。 IPC命名空间负责在每个容器之间运行的进程之间隔离IPC资源。</li>
<li>USER：此命名空间用于隔离每个容器中的用户。与主机系统相比，它允许容器具有不同的uid（用户ID）和gid（组ID）范围的视图。因此，进程的uid和gid在用户命名空间内外可能会有所不同，这也允许进程在容器之外拥有无特权用户，而不会牺牲容器内的root权限。</li>
</ul>
<p>Docker将这些命名空间一起使用，以便隔离并开始创建容器。</p>
<p>2  <strong>控制组(Control groups)</strong></p>
<p>控制组（也称为cgroups）是一个Linux内核功能，可以隔离，优先排列和记录一组进程的资源使用情况（CPU，内存，磁盘I / O，网络等）。在这个意义上，一个cgroup可以确保Docker容器只能使用他们需要的资源，如果需要，可以设置容器*可以使用什么资源的限制。 Cgroups还确保单个容器不会耗尽其中一个资源并将整个系统关闭。</p>
<p><strong>Docker的未来：Docker和VM将共存</strong></p>
<p>Docker肯定会获得很大的收益，但我不相信它将成为虚拟机的真正威胁。容器将继续获得成功，但有许多使用虚拟机仍然更适合的用例。<br>例如，如果您需要在多个服务器上运行多个应用程序，则使用虚拟机可能是有意义的。另一方面，如果您需要运行多个<em>副本</em>的单个应用程序，Docker提供了一些引人注目的优势。<br>此外，Docker允许您将应用程序分解成更多功能分立的部件，从而创建分离的关注点，这也意味着越来越多的部件要管理，这可能会变得笨重。<br>Docker容器的安全性也是一个令人关切的问题，因为容器共享相同的内核，容器间的隔离更薄。完整的VM只能向主机管理程序发出超级呼叫，Docker容器可以将系统调用到主机内核，从而创建更大的攻击面。当安全性特别重要时，开发人员可能会选择通过抽象硬件隔离的虚拟机，使得彼此之间的干扰更加困难。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/13/WebSockets-介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谢晖">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谢晖的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/13/WebSockets-介绍/" itemprop="url">
                  WebSockets 介绍
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-13T22:11:37+08:00">
                2017-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index">
                    <span itemprop="name">Web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/13/WebSockets-介绍/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/13/WebSockets-介绍/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="WebSockets介绍"><a href="#WebSockets介绍" class="headerlink" title="WebSockets介绍"></a>WebSockets介绍</h1><p>WebSocket是允许客户端和服务器/端点之间使用单个TCP连接进行通信的协议。听起来有点像http不是吗？ WebSocket通过HTTP的优势是协议是全双工的（允许同时进行双向通信），它的头部比HTTP头部要小得多，因此即使在小数据包上也能实现更高效的通信。</p>
<p>WebSocket的生命周期也很容易理解：</p>
<ol>
<li><p>客户端以HTTP升级标头的形式向服务器发送握手请求，并提供有关其尝试连接到的WebSocket的数据。</p>
</li>
<li><p>服务器使用另一个HTTP头响应请求，这是WebSocket连接中最后一次使用HTTP头。如果握手成功，则服务器发送HTTP头，告知客户端切换到WebSocket协议。</p>
</li>
<li><p>现在打开一个常量连接，客户端和服务器可以在连接关闭之前发送任何数量的消息。这些消息只有大约2字节的开销。</p>
</li>
</ol>
<p>我们知道，传统的HTTP协议是无状态的，每次请求（request）都要由客户端（如 浏览器）主动发起，服务端进行处理后返回response结果，而服务端很难主动向客户端发送数据；这种客户端是主动方，服务端是被动方的传统Web模式 对于信息变化不频繁的Web应用来说造成的麻烦较小，而对于涉及实时信息的Web应用却带来了很大的不便，如带有即时通信、实时数据、订阅推送等功能的应 用。在WebSocket规范提出之前，开发人员若要实现这些实时性较强的功能，经常会使用折衷的解决方法：轮询（polling）和Comet技术。其实后者本质上也是一种轮询，只不过有所改进。</p>
<p>　　轮询是最原始的实现实时Web应用的解决方案。轮询技术要求客户端以设定的时间间隔周期性地向服务端发送请求，频繁地查询是否有新的数据改动。明显地，这种方法会导致过多不必要的请求，浪费流量和服务器资源。</p>
<p>　　Comet技术又可以分为长轮询和流技术。长轮询改进了上述的轮询技术，减小了无用的请求。它会为某些数据设定过期时间，当数据过期后才会向服务端发送请求；这种机制适合数据的改动不是特别频繁的情况。流技术通常是指客户端使用一个隐藏的窗口与服务端建立一个HTTP长连接，服务端会不断更新连接状态以保持HTTP长连接存活；这样的话，服务端就可以通过这条长连接主动将数据发送给客户端；流技术在大并发环境下，可能会考验到服务端的性能。</p>
<p>　　这两种技术都是基于请求-应答模式，都不算是真正意义上的实时技术；它们的每一次请求、应答，都浪费了一定流量在相同的头部信息上，并且开发复杂度也较大。</p>
<p>　　伴随着HTML5推出的WebSocket，真正实现了Web的实时通信，使B/S模式具备了C/S模式的实时通信能力。WebSocket的工作流程是这 样的：浏览器通过JavaScript向服务端发出建立WebSocket连接的请求，在WebSocket连接建立成功后，客户端和服务端就可以通过 TCP连接传输数据。因为WebSocket连接本质上是TCP连接，不需要每次传输都带上重复的头部数据，所以它的数据传输量比轮询和Comet技术小 了很多。</p>
<h1 id="WebSockets是如何工作的？"><a href="#WebSockets是如何工作的？" class="headerlink" title="WebSockets是如何工作的？"></a>WebSockets是如何工作的？</h1><p>WebSockets提供客户端和服务器之间的持久连接，双方可以随时使用该连接开始发送数据。</p>
<p>客户端通过称为WebSocket握手的进程建立WebSocket连接。 此过程从客户端向服务器发送常规HTTP请求开始。 此请求中包含升级标头，通知服务器客户端希望建立WebSocket连接。</p>
<p>以下是初始请求标头的简化示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GET ws://websocket.example.com/ HTTP/1.1</div><div class="line">Origin: http://example.com</div><div class="line">Connection: Upgrade</div><div class="line">Host: websocket.example.com</div><div class="line">Upgrade: websocket</div></pre></td></tr></table></figure>
<p><strong>注意</strong>：WebSocket URL使用ws方案。 对于安全的WebSocket连接，也是相当于HTTPS的wss。</p>
<p>如果服务器支持WebSocket协议，则它同意升级，并通过响应中的升级标头进行通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 101 WebSocket Protocol Handshake</div><div class="line">Date: Wed, 16 Oct 2013 10:07:34 GMT</div><div class="line">Connection: Upgrade</div><div class="line">Upgrade: WebSocket</div></pre></td></tr></table></figure>
<p>现在握手已经完成，初始的HTTP连接被使用相同底层TCP / IP连接的WebSocket连接取代。 此时任何一方都可以开始发送数据。</p>
<p>使用WebSockets，您可以传输尽可能多的数据，而不会产生与传统HTTP请求相关的开销。 数据通过WebSocket作为消息传输，每个消息由包含要发送的数据（有效载荷）的一个或多个帧组成。 为了确保在到达客户端时能够正确地重构消息，每个帧都以4-12字节的有效载荷数据为前缀。 使用这种基于帧的消息系统有助于减少传输的非有效负载数据的数量，从而显着降低延迟。</p>
<p><strong>注意</strong>：值得注意的是，一旦接收到所有的帧并重建了原始的消息有效载荷，客户端才会被通知一个新的消息。</p>
<h1 id="WebSockets协议"><a href="#WebSockets协议" class="headerlink" title="WebSockets协议"></a>WebSockets协议</h1><p>WebSockets有线协议（RFC 6455）包括两个高级组件：用于协商连接参数的开放HTTP握手和二进制消息构框机制，以允许低开销，基于消息的传送 的文本和二进制数据。</p>
<p>WebSockets协议尝试在现有HTTP基础架构的上下文中解决现有双向HTTP技术的目标; 因此，它被设计为通过HTTP端口80和443进行工作。但是，该设计不会将WebSocket限制为HTTP，并且将来的实现可以在专用端口上使用更简单的握手，而无需重新整理整个协议。</p>
<p>WebSockets协议是一种功能齐全的独立协议，可以在浏览器之外使用。 话虽如此，它的主要应用还是基于浏览器的应用程序的双向传输。</p>
<h2 id="二进制框架层"><a href="#二进制框架层" class="headerlink" title="二进制框架层"></a>二进制框架层</h2><p>客户端和服务器WebSocket应用程序通过面向消息的API进行通信：发送方提供任意的UTF-8或二进制有效负载，并且当整个消息可用时，接收方通知其传送。 为了实现这一点，WebSocket使用自定义的二进制成帧格式（如下图），它将每个应用消息分解成一个或多个帧，将它们传输到目的地，重新组合它们，并且一旦接收到整个消息，最后通知接收器 。</p>
<p><img src="https://hpbn.co/assets/diagrams/efb151be6600eb5555127c8652488f1f.svg" alt="WebSockets协议"></p>
<p><em>帧</em></p>
<p>通信的最小单位，每个包含可变长度的帧头和可以携带全部或部分应用消息的有效载荷。</p>
<p><em>消息</em></p>
<p>映射到逻辑应用程序消息的完整的帧序列。</p>
<p>将应用消息分解成多个帧的决定是由客户端和服务器帧代码的底层实现来实现的。 因此，应用程序仍然幸福地不知道单个WebSocket框架或框架的执行方式。 话虽如此，了解每个WebSocket框架如何在电线上表现的重点仍然是有用的：</p>
<ul>
<li><p>每帧的第一位（FIN）指示该帧是否是消息的最终片段。 消息可能只包含一个帧。</p>
</li>
<li><p>操作码（4位）表示传送帧的类型：用于传送应用数据的文本（1）或二进制（2）或连接关闭（8），ping（9）和pong （10）等控制帧，用于连接活动 检查。</p>
</li>
<li><p>掩码位指示有效负载是否被屏蔽（对于从客户端发送到服务器的消息）。</p>
</li>
<li><p>有效负载长度表示为可变长度字段：</p>
<ul>
<li><p>如果0-125，那就是有效载荷长度。</p>
</li>
<li><p>如果为126，那么以下2个字节表示一个16位无符号整数，表示帧长度。</p>
</li>
<li><p>如果127，那么以下8个字节表示一个64位无符号整数，表示帧长度。</p>
</li>
</ul>
</li>
<li><p>屏蔽键包含用于屏蔽有效载荷的32位值。</p>
</li>
<li><p>如果客户端和服务器在建立连接时协商扩展，Payload包含应用程序数据和自定义扩展数据。</p>
<p><strong>注意</strong>：所有客户端发起的帧的有效负载都使用帧头中指定的值进行屏蔽：这样可以防止在客户端上执行的恶意脚本对可能无法理解WebSocket协议的中间人执行缓存中毒攻击。</p>
</li>
</ul>
<p>因此，每个服务器发送的WebSocket框架产生2-10个字节的帧开销。 客户端还必须发送一个掩码密钥，该密钥向头添加额外的4个字节，从而导致6-14个字节的开销。 没有其他元数据，例如头域或有关有效载荷的其他信息可用：所有WebSocket通信都是通过交换将处理有效载荷作为不透明的应用程序数据的帧来执行的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/13/一个基于-NET轻量级的Web框架-Nancy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谢晖">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谢晖的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/13/一个基于-NET轻量级的Web框架-Nancy/" itemprop="url">
                  一个基于.NET轻量级的Web框架:Nancy
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-13T21:12:15+08:00">
                2017-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NET/" itemprop="url" rel="index">
                    <span itemprop="name">.NET</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/13/一个基于-NET轻量级的Web框架-Nancy/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/13/一个基于-NET轻量级的Web框架-Nancy/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Nancy框架介绍"><a href="#Nancy框架介绍" class="headerlink" title="Nancy框架介绍"></a>Nancy框架介绍</h1><p>Nancy是一个轻量级的低成本框架，用于在.NET和Mono上构建基于HTTP的服务。框架的目标是尽可能的避开障碍，为所有的互动提供超级快乐的路径。</p>
<p>这意味着Nancy的所有内容都被设置为具有明智的默认和约定，而不是让你跳过环，并且通过配置，只是为了起床和运行。与Nancy，你可以从零到网站在几分钟内。字面上</p>
<p>Nancy旨在处理DELETE，GET，HEAD，OPTIONS，POST，PUT和PATCH请求，并提供简单，优雅的域特定语言（DSL），只需几次按键即可返回响应，让您有更多的时间聚焦在重要的位..你的代码和你的应用程序。</p>
<p>所有这一切都是由社区构建的，作为一个开源框架，意味着您可以完全访问源代码，并根据MIT许可证获得许可。</p>
<p>您可以从Nuget，TeamCity服务器（最新版本）获取Nancy或从GitHub存储库下载源代码。</p>
<h1 id="轻量级"><a href="#轻量级" class="headerlink" title="轻量级"></a>轻量级</h1><p>Nancy是一个轻量级的低成本框架是一个小的，非常容易使用REST和服务框架。<br>你可以代替ASP.NET MVC中使用它;您可以在自托管环境中使用它自己的，就像如果你正在部署使用例如应用程序的NodeJS你可能会做的。<br>Nancy的实力，然而，来自远不止其微小的尺寸。在默认安装，它管理包一个完整的IoC容器，一个内置的测试框架，建立一些非常复杂的路由规则的能力，以及一个模块化的架构，使得它令人惊讶的简单与很少或根本没有额外的功能。</p>
<h1 id="任何地方运行"><a href="#任何地方运行" class="headerlink" title="任何地方运行"></a>任何地方运行</h1><p>Nancy是建立在任何地方运行。从一开始Nancy就被设计成不会对现有框架的依赖。内置与.NET Framework客户端配置文件，Nancy可不管你想要的，因为它完全包含有自己的请求和响应对象自我使用相当多。<br>一个在Nancy的核心概念是主机。主机充当主机环境和Nancy，从而使Nancy在现有的技术，如ASP.NET，WCF和OWIN运行的适配器，或集成在任何给定的应用。 </p>
<p>特定主机实现不随核心Nancy框架。他们是分开包装的，因为有很多其他的附加功能，如窗体身份验证，从前面提到的来源。构建Nancy应用程序就像是从一个Web框架自助挑选自己喜欢的部分！通常构建Nancy服务时，将使用最低限度的核心框架和主机。</p>
<h1 id="The-super-duper-happy-path"><a href="#The-super-duper-happy-path" class="headerlink" title="The super-duper-happy-path"></a>The super-duper-happy-path</h1><p>虽然很难准确地确定它是什么，但这毕竟是一个非常感性的术语，但它背后的基本想法是：</p>
<ul>
<li><p>“它只是工作” - 你应该可以拿起东西，使用它们，而不会有任何污点。增加了一个新的模块？这是自动发现的。引进了一个新的查看引擎？所有的连线都可以随时准备，而无需执行任何其他操作。即使您向模块添加了新的依赖项，默认情况下，我们将找到该注册表并为其注入 - 不需要配置。</p>
</li>
<li><p>“轻松可定制” - 即使“只是工作”，如果您想要使用要使用的组件的方式工作，则不应该存在阻碍自定义方式的障碍。想要使用另一个容器？没问题！想要调整路线选择的方式吗？前进！通过我们的bootstrapper方法，所有这些都应该是一块蛋糕。</p>
</li>
<li><p>“低礼” - 您在申请中应该需要的“Nancy code”数量应该很少。任何Nancy应用程序的重要部分是您的代码 - 我们的代码应该摆脱您的方式，让您继续构建真棒应用程序。作为一个证明，实际上可以将一个功能性的Nancy应用程序适用于一个单独的Tweet。</p>
</li>
<li><p>“低摩擦” - 当与Nancy一起构建软件时，API应该可以帮助您获得想要去的地方，而不是进入您的路。命名应该是显而易见的，所需的配置应该是最小的，但是当你需要时，功率和可扩展性应该仍然存在。<br>最重要的是，与Nancy创造应用程序应该是一种荣幸，希望有趣！但不会牺牲您的应用程序增长所需的功能或扩展性。</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/12/node-js-为何如此流行/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谢晖">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谢晖的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/12/node-js-为何如此流行/" itemprop="url">
                  node.js 为何如此流行?
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-12T22:09:26+08:00">
                2017-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/12/node-js-为何如此流行/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/12/node-js-为何如此流行/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="node-js-为何如此流行"><a href="#node-js-为何如此流行" class="headerlink" title="node.js 为何如此流行?"></a>node.js 为何如此流行?</h1><p>Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。<br>Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。<br>Node.js服务器技术用于创建和运行各种Web应用程序，与Ruby On Rails，Spring Framework和ASP.NET相似。 它利用JavaScript作为主要语言，它是一个轻量级的内置Web服务器，并且通过节点包管理器（NPM）管理了大量的插件，可让您自定义构建应用程序以满足您的需求。 它可能听起来像任何其他好的网络技术，但它具有某些功能，使其成为开发人员构建广泛的Web应用程序的受欢迎的选择。</p>
<h2 id="它是无处不在的JavaScript"><a href="#它是无处不在的JavaScript" class="headerlink" title="它是无处不在的JavaScript"></a>它是无处不在的JavaScript</h2><p>Node.js如此受欢迎的最大原因之一是因为它使用JavaScript作为其主要语言来构建Web应用程序。 说实话，JavaScript现在是在浏览器中开发Web应用程序的唯一选择。 还有什么！ 引入了一个新的，稳健的框架来引导开发人员。 使用Node.js，JavaScript在服务器上已经彻底革新了。 这种语言对于大多数网络开发者是很常见的，当然也是当今这个世界的驱动。 据专家说，这个趋势不会很快消失。</p>
<p>由于JavaScript是大多数开发人员在某个时间点知道或已经使用的语言，因此从另一个Web技术到Node.js的转换是轻而易举的。 这使得它成为Web开发人员的首选。</p>
<h3 id="快如闪电"><a href="#快如闪电" class="headerlink" title="快如闪电"></a>快如闪电</h3><p> V8具有以快速的速度编译和执行JavaScript的能力，主要是因为它将JavaScript编译成本机代码。除此之外，Node.js还有一个神奇的事件循环，它是以一个异步方式执行所有I / O操作的单个线程。在Node.js中，当应用程序必须执行I / O操作时，它会向事件循环发送异步任务和回调操作，然后继续执行程序的其余部分。完成同步操作后，事件循环将自动返回到执行回调任务。这与传统的循环非常不同，传统的循环消耗了大量的内存，非常难以执行。</p>
<p>因此，在Node中非常快速地执行文件系统，网络连接和数据库的读/写操作。它允许开发人员构建快速和高度可扩展的网络应用程序，能够处理大量同时具有高吞吐量的连接。</p>
<h3 id="它是轻量级的"><a href="#它是轻量级的" class="headerlink" title="它是轻量级的"></a>它是轻量级的</h3><p>通常，Node.js使用基本的事件驱动架构。 这意味着它上执行的一切，包括每一个操作和调用，都是一系列异步回调。 这使得Node能够在单个线程上运行，与其他针对每个客户端请求产生新线程的Web技术不同。 这不仅使其轻巧，而且还构成了Node的非阻塞I / O功能的基础。</p>
<h3 id="低学习成本"><a href="#低学习成本" class="headerlink" title="低学习成本"></a>低学习成本</h3><p>Node.js的另一个主要优点是语言重用。像Spring或ASP.NET这样的其他网络技术要求开发人员使用另一种语言来编写服务器端的代码，无论是VB.NET，Java还是C＃。这意味着所有功能必须包括两种语言 - 一种在客户端，另一种在服务器端。相反，Node仅在客户端和服务器端使用JavaScript。因此，Web开发人员必须在所有层中以单一语言进行交互。除此之外，这可以一遍又一遍地重新用于将来的通信。</p>
<h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>PayPal使用Node.js，并且报告每秒钟的请求数量翻了一番，并将响应时间缩短了35％。另一方面，零售巨头沃尔玛则在2013年的Node.js中获得了卓越的经验，当时他们将所有通过Node.js进行的移动通信业务都放在黑色星期五，这是当年最繁忙的购物时间。令人惊讶的是，在黑色星期五，沃尔玛服务器的CPU利用率只有1％，而在线部署的用户达到了2亿。 LinkedIn，全球网站，从Ruby转移到Node处理移动流量，将服务器数量减少到30到3，即减少了近90％。新系统的速度提高了20倍。所有这些数字清楚地表明了Node.js的性能能力。</p>
<h3 id="跨平台功能"><a href="#跨平台功能" class="headerlink" title="跨平台功能"></a>跨平台功能</h3><p>Node.js也是跨平台的。 与Java类似，Node运行时适用于嵌入式系统，Linux和Unix，Windows服务器和桌面以及Mac OS X的所有标准版本。这意味着您可以选择您的软件，只要您小心不要写 任何特定于您期望的文件系统或结构的任何内容，您都可以期望它能在任何地方运行。 这对于可移植性是非常有利的，而不必编写新的代码或实现新的库。</p>
<h3 id="占用空间小"><a href="#占用空间小" class="headerlink" title="占用空间小"></a>占用空间小</h3><p>Node.js如此受欢迎的另一个原因是运行它的空间很小。 这使得可以将Node运行时嵌入到用于物联网（IoT）应用的低功耗设备，例如支持Web的家庭恒温器或车库门开启器。 这不是一个沉重的系统，所以你可以把它放在嵌入式，小型和便宜的东西上。 这样可以轻松地在Raspberry Pi或Arduino板上运行Node，并执行小型自动化任务，而无需担心语言的膨胀。</p>
<h3 id="易于修改和维护"><a href="#易于修改和维护" class="headerlink" title="易于修改和维护"></a>易于修改和维护</h3><p>Node.js采用模块化设计, Node.js使用Module模块去划分不同的功能，以简化应用的开发。Modules模块有点像C++语言中的类库。每一个Node.js的类库都包含了十分丰富的各类函数，比如http模块就包含了和http功能相关的很多函数，可以帮助开发者很容易地对比如http,tcp/udp等进行操作，还可以很容易的创建http和tcp/udp的服务器。</p>
<h3 id="NPM-The-Node-Package-Manager"><a href="#NPM-The-Node-Package-Manager" class="headerlink" title="NPM: The Node Package Manager"></a>NPM: The Node Package Manager</h3><p>当我们讨论 Node.js 的时候，一个绝对不应该忽略地方就是默认内置的模块管理工具 —— NPM。 其灵感来源与 Ruby Gems（具有版本和依赖管理功能，可以通过在线资料库便捷安装可重用的组件的管理工具）。</p>
<p>当然上面举了这么多Node.js的优点，Node.js的优点远不止这些，当然说了Node.js这么多优点，其实也存在一些缺点的，毕竟不能面面俱到，总之Node.js能响应大量的并发请求，Node.js适合运用在高并发、I/O密集、少量业务逻辑的场景。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/11/kafka-介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谢晖">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谢晖的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/11/kafka-介绍/" itemprop="url">
                  kafka 介绍
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-11T21:30:25+08:00">
                2017-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Big-Data/" itemprop="url" rel="index">
                    <span itemprop="name">Big Data</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/11/kafka-介绍/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/11/kafka-介绍/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h3 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h3><p>Kafka是一种分布式的，基于发布/订阅的消息系统。主要设计目标如下：</p>
<ul>
<li><p>以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间复杂度的访问性能。</p>
</li>
<li><p>高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条以上消息的传输。</p>
</li>
<li><p>支持Kafka Server间的消息分区，及分布式消费，同时保证每个Partition内的消息顺序传输。</p>
</li>
<li><p>同时支持离线数据处理和实时数据处理。</p>
</li>
<li><p>支持在线水平扩展。</p>
</li>
</ul>
<h3 id="为何使用消息系统"><a href="#为何使用消息系统" class="headerlink" title="为何使用消息系统"></a>为何使用消息系统</h3><ul>
<li><p>解耦</p>
<p>在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。</p>
</li>
<li><p>冗余</p>
<p>有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。</p>
</li>
<li><p>扩展性</p>
<p>因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。</p>
</li>
<li><p>灵活性 &amp; 峰值处理能力</p>
<p>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。</p>
</li>
<li><p>可恢复性</p>
<p>系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。</p>
</li>
<li><p>顺序保证</p>
<p>在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。Kafka保证一个Partition内的消息的有序性。</p>
</li>
<li><p>缓冲</p>
<p>在任何重要的系统中，都会有需要不同的处理时间的元素。例如，加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行———写入队列的处理会尽可能的快速。该缓冲有助于控制和优化数据流经过系统的速度。</p>
</li>
<li><p>异步通信</p>
<p>很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p>
</li>
</ul>
<h3 id="Apache-kafka是一个分布式流媒体平台。这到底是什么意思呢"><a href="#Apache-kafka是一个分布式流媒体平台。这到底是什么意思呢" class="headerlink" title="Apache kafka是一个分布式流媒体平台。这到底是什么意思呢?"></a>Apache kafka是一个分布式流媒体平台。这到底是什么意思呢?</h3><p>一个流媒体平台应具有三个关键能力：</p>
<ol>
<li><p>它可以让你发布和订阅的记录流。在这方面，它类似于一个消息队列或企业信息系统。</p>
</li>
<li><p>它可以让你存储的记录中的流容错方式。</p>
</li>
<li><p>它可以让他们出现您处理的记录流。</p>
</li>
</ol>
<h3 id="什么场景下使用Kafka"><a href="#什么场景下使用Kafka" class="headerlink" title="什么场景下使用Kafka?"></a>什么场景下使用Kafka?</h3><p>它被用于两大类应用：</p>
<ol>
<li><p>建立实时流数据管道不仅能够可靠地获得系统或应用程序之间的数据。</p>
</li>
<li><p>构建实时流式变换或反应数据流应用。</p>
</li>
</ol>
<h3 id="kafka-相关概念"><a href="#kafka-相关概念" class="headerlink" title="kafka 相关概念"></a>kafka 相关概念</h3><p>首先确定几个概念：</p>
<ul>
<li><p>Message: 消息，是通信的基本单位，每个producer可以向一个topic（主题）发布一些消息。</p>
</li>
<li><p>Broker: Kafka集群包含一个或多个服务器，这种服务器被称为broker。</p>
</li>
<li><p>Topic: 每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic，在其他消息队列系统里面叫做队列名。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</p>
</li>
<li><p>Partition: Partition是物理上的概念，每个Topic包含一个或多个Partition。</p>
</li>
<li><p>Producer: 消息生产者，发布消息到 kafka 集群的终端或服务。</p>
</li>
<li><p>Consumer:消息消费者，向Kafka broker读取消息的客户端。</p>
</li>
<li><p>Consumer group：high-level consumer API 中，每个 consumer 都属于一个 consumer group，每条消息只能被 consumer group 中的一个 Consumer 消费，但可以被多个 consumer group 消费。（可为每个Consumer指定group name，若不指定group name则属于默认的group）。</p>
</li>
<li><p>kafka运在一个或多个服务器集群。</p>
</li>
<li><p>在被称为主题类别的kafka集群存储的记录流。</p>
</li>
<li><p>每个记录包含一个键，值和时间戳。</p>
</li>
</ul>
<p>kafka有四个核心API：</p>
<ul>
<li><p>生产者API允许应用程序发布的记录流至一个或多个kafka的topic。</p>
</li>
<li><p>消费者API允许应用程序订阅一个或多个主题，并处理所产生的对他们记录的数据流。</p>
</li>
<li><p>流API允许应用程序充当流处理器从一个或多个主题消耗的输入流，并产生一个输出流至一个或多个输出的主题，有效地变换所述输入流，以输出流。</p>
</li>
<li><p>连接器API允许构建和运行kafka topic连接到现有的应用程序或数据系统中重用生产者或消费者。例如，一个连接到关系数据库可能会捕捉每一个变化表。</p>
</li>
</ul>
<p><img src="http://kafka.apache.org/0102/images/kafka-apis.png" alt="kafka apis"></p>
<p>在kafka的客户端和服务器之间的通信是一个简单的，高性能的，与语言无关的TCP协议来完成。此协议版本，并保持向后兼容旧版本的兼容性。我们对kafka提供了一个Java客户端，但是客户端有<a href="https://cwiki.apache.org/confluence/display/KAFKA/Clients" target="_blank" rel="external">多种语言</a>可供选择。</p>
<h3 id="Kafka的架构："><a href="#Kafka的架构：" class="headerlink" title="Kafka的架构："></a>Kafka的架构：</h3><p><img src="http://jbcdn2.b0.upaiyun.com/2014/08/975609a391574a15645c2d2e2494114f.png" alt="kafka apis"></p>
<p>Kafka的整体架构非常简单，是显式分布式架构，producer、broker（kafka）和consumer都可以有多个。Producer，consumer实现Kafka注册的接口，数据从producer发送到broker，broker承担一个中间缓存和分发的作用。<br>broker分发注册到系统中的consumer。broker的作用类似于缓存，即活跃的数据和离线处理系统之间的缓存。客户端和服务器端的通信，是基于简单，高性能，且与编程语言无关的TCP协议。</p>
<h4 id="消息发送的流程："><a href="#消息发送的流程：" class="headerlink" title="消息发送的流程："></a>消息发送的流程：</h4><p><img src="http://jbcdn2.b0.upaiyun.com/2014/08/cb5892023c894331a55de5ac7f64582d.png" alt="kafka apis"></p>
<ol>
<li><p>Producer根据指定的partition方法（round-robin、hash等），将消息发布到指定topic的partition里面。</p>
</li>
<li><p>kafka集群接收到Producer发过来的消息后，将其持久化到硬盘，并保留消息指定时长（可配置），而不关注消息是否被消费。</p>
</li>
<li><p>Consumer从kafka集群pull数据，并控制获取消息的offset。 </p>
</li>
</ol>
<h3 id="Kafka的设计："><a href="#Kafka的设计：" class="headerlink" title="Kafka的设计："></a>Kafka的设计：</h3><p>   1、<strong>吞吐量</strong></p>
<pre><code>高吞吐是kafka需要实现的核心目标之一，为此kafka做了以下一些设计：

1、数据磁盘持久化：消息不在内存中cache，直接写入到磁盘，充分利用磁盘的顺序读写性能；

2、zero-copy：减少IO操作步骤；

3、数据批量发送；

4、数据压缩；

5、Topic划分为多个partition，提高parallelism；
</code></pre><p>   2、<strong>负载均衡</strong></p>
<pre><code>1、producer根据用户指定的算法，将消息发送到指定的partition；

2、存在多个partiiton，每个partition有自己的replica，每个replica分布在不同的Broker节点上；

3、多个partition需要选取出lead partition，lead partition负责读写，并由zookeeper负责fail over；

4、通过zookeeper管理broker与consumer的动态加入与离开；
</code></pre><p>   3、<strong>拉取系统</strong></p>
<pre><code>由于kafka broker会持久化数据，broker没有内存压力，因此，consumer非常适合采取pull的方式消费数据，具有以下几点好处：

1、简化kafka设计；

2、consumer根据消费能力自主控制消息拉取速度；

3、consumer根据自身情况自主选择消费模式，例如批量，重复消费，从尾端开始消费等；
</code></pre><p>   4、<strong>可扩展性</strong></p>
<pre><code>1、当需要增加broker结点时，新增的broker会向zookeeper注册，而producer及consumer会根据注册在zookeeper上的watcher感知这些变化，并及时作出调整。
</code></pre><h3 id="Topics-and-Logs-主题和日志"><a href="#Topics-and-Logs-主题和日志" class="headerlink" title="Topics and Logs(主题和日志)"></a>Topics and Logs(主题和日志)</h3><p>让我们先潜入核心抽象kafka提供了记录，该主题的流。 </p>
<p>Topic是作为一类消息名称记录被公布。在kafka的Topic始终是多用户;也就是说，一个Topic可以有零个，一个或多个消费者订阅写入的数据。 </p>
<p>对于每一个主题，Topic集群保持分区日志，看起来像这样：</p>
<p><img src="http://kafka.apache.org/0102/images/log_anatomy.png" alt="kafka apis"></p>
<p>每个分区是记录一个有序的，一成不变的序列不断追加到一个结构化的提交日志。</p>
<p>在分区中的记录是调用的每个分配的序列ID号的偏移量唯一地标识该分区中的每个记录。</p>
<p>kafka集群保留所有发布的记录，不论其是否具有可配置的保留期限被使用或消费。例如，如果将保留策略设置为两天，然后记录公布后两天，它可用于消费，之后它将被丢弃以腾出空间。kafka的性能相对于数据的大小实际上不变，以便将数据存储很长一段时间是没有问题的。</p>
<p><img src="http://kafka.apache.org/0102/images/log_consumer.png" alt="kafka apis"></p>
<p>事实上，保留在每个消费者基础的唯一的元数据是在日志中，消费者的偏移或位置。这种偏移是由消费者控制：通常消费者会促进其线性偏移，因为它读取记录，但事实上，因为其位置是由消费者可以在任何它喜欢的顺序消耗记录进行控制。例如，消费者可以恢复到旧的偏移量从过去的数据再加工或者直接跳到最新的记录，并开始从“现在”消费。</p>
<p>这些功能的结合意味着，kafka的消费者都是很便宜的，他们可以来去无集群上或其他消费者产生太大影响。例如，你可以使用我们的命令行工具“tail”的任何话题，而无需改变什么是任何现有的消费者消费的内容。</p>
<p>日志中的分区，一举数得。首先，它们允许日志扩展到超过一个的大小，将适合在单个服务器上。每个单独的分区必须适合承载它的服务器上，但一个话题可能有很多分区，以便它能够处理任意的数据量。其次，他们作为并行性更上一个位的单位。</p>
<h3 id="Distribution-分布式"><a href="#Distribution-分布式" class="headerlink" title="Distribution(分布式)"></a>Distribution(分布式)</h3><p>日志的分区分布在每台服务器处理数据和请求对分区的份额kafka集群中的服务器。每个分区跨容错服务器配置数量的复制。<br>每个分区有它充当“leader”和零个或多个服务器充当“followers”一台服务器。领导者处理所有的读取和写入分区的要求而被动的追随者复制的领导者。如果领导者失败了，追随者之一将自动成为新的领导者。每个服务器充当一些分区，而对其他跟随的领导者这样的负载是在集群内均衡。</p>
<h3 id="Producers-生产者"><a href="#Producers-生产者" class="headerlink" title="Producers(生产者)"></a>Producers(生产者)</h3><p>生产者数据发布到他们所选择的主题。制片人负责选择分配哪些记录在主题中哪个分区。这可以在一个循环的方式进行简单地平衡负载，也可以根据一些语义分区功能（比如基于记录一些关键）来完成。更多关于在第二使用分区！</p>
<h3 id="Consumers-消费者"><a href="#Consumers-消费者" class="headerlink" title="Consumers(消费者)"></a>Consumers(消费者)</h3><p>消费者标榜自己与消费者的组名，并发布到一个话题每个记录每个订阅用户组内交付给消费者的一个实例。消费实例可以在单独的进程或单独的机器上。<br>如果所有的消费者实例具有相同的消费群，那么记录将有效地加载在消费者实例平衡。<br>如果所有的消费者实例有不同的消费群体，那么每个记录将被广播到所有的消费过程。</p>
<p><img src="http://kafka.apache.org/0102/images/consumer-groups.png" alt="kafka apis"></p>
<p>两个服务器集群kafka举办两个消费群体的四个分区（P0-P3）。一个消费群体有两个消费情况与B组有四个。<br>更常见的，但是，我们已经发现，主题有一个小的消费群体，每一个“逻辑用户”的。每组都是由可扩展性和容错许多消费者实例。这只不过是发布 - 订阅语义在那里用户是消费者，而不是一个单一的过程中群集的更多。<br>消费kafka的实现方式是通过将建立分区日志在Consumer实例，使每个实例是分区的“公平份额”的在任何时间点的独家消费者。维持组中的成员的这个过程是通过动态kafka协议处理。如果新的实例加入该组，他们将接管从该组的其他成员一些分区;如果一个实例死亡，其分区将被分配到剩余的实例。<br>kafka只提供了记录的总订单分区中，而不是一个主题的不同分区之间。每个分区的顺序与键对数据进行分区的能力相结合足以满足大多数应用。但是，如果在记录总共需要为了这个可以与只有一个分区的主题实现的，虽然这将意味着只有一个每个消费群体的消费过程。</p>
<h3 id="kafka-作为一个消息系统"><a href="#kafka-作为一个消息系统" class="headerlink" title="kafka 作为一个消息系统"></a>kafka 作为一个消息系统</h3><p>如何流的kafka的观念比较传统的企业信息系统？<br>消息历来有两种模型：队列和发布 - 订阅。在队列中，消费者的池可以从服务器读取和记录每一个进入其中的一个;在发布 - 订阅记录被广播到所有的消费者。每个这两种模式具有一定的实力和弱点。排队的优点是它可以让你瓜分了数据在多个消费情况的处理，它可以让您扩展您的处理。不幸的是，队列不是多用户，一旦一个进程读取它不见了数据。发布 - 订阅模式可以让你广播数据到多个进程，但没有，因为每一个消息发送到每个用户的缩放处理的方式。<br>在kafka的消费群的概念推广这两个概念。与队列的消费群让你过的进程的集合（消费群的成员）瓜分处理。与发布 - 订阅，kafka让您发送广播消息到多个消费群体。<br>kafka的模型的优点是，每个主题都有两个属性，它可以扩展的处理，也是多用户，有没有必要选择一个或另一个。<br>kafka具有较强的排序保证比传统的消息系统了。<br>传统的队列保留在服务器上，订单记录，如果多个消费者从队列中消耗那么服务器双手出存储它们的订单记录。然而，尽管服务器为了捧出来的记录，这些记录被异步传递给消费者，让他们可以在不同的消费者到达的顺序。这实际上意味着记录的排序在并行消费的存在都将丢失。消息系统通常解决这个具有“排他性消费”，只允许一个过程从队列中消耗的概念，当然，这意味着有正在处理的并行性。<br>kafka做的更好。通过具有一个概念并行性的分区中的主题，kafka是能够通过消费者的进程池同时提供排序保证和负载平衡。这是通过使每个分区由该组中只有一个消费者所消耗的话题，消费者的消费群在指定的分区来实现的。通过这样做，我们确保消费者的是，分区唯一的读者，为了消耗数据。因为有许多的分区，这还是平衡了许多消费者的情况下的负载。但是请注意，不能在一个消费群体比分区的详细消费情况。</p>
<h3 id="kafka-作为一个存储系统"><a href="#kafka-作为一个存储系统" class="headerlink" title="kafka 作为一个存储系统"></a>kafka 作为一个存储系统</h3><p>任何消息队列，它允许从消费他们解耦出版消息被有效地充当用于在飞行中消息的存储系统。这就是kafka与其他消息队列系统不同的地方，因为它是一个很好的存储系统。<br>写到kafka数据写入到磁盘和复制的容错。kafka允许生产者在确认等待，以便不被认为是写操作完成，直到它被完全复制，并保证持续下去，即使写入服务器失败。<br>磁盘结构kafka使用很好地扩展，kafka将执行相同的你是否有50 KB或服务器上的持久性数据的50 TB。<br>由于把存储的重视，并允许客户控制自己的读取位置的结果，你能想到kafka作为一种特殊用途的分布式文件系统，致力于高性能，低延迟提交日志存储，复制和传播。</p>
<h3 id="kafka-流处理"><a href="#kafka-流处理" class="headerlink" title="kafka 流处理"></a>kafka 流处理</h3><p>这是不够的，只是读，写，以及数据的储存流，目的是使数据流的实时处理。<br>在kafka流处理器是任何需要从输入的主题数据的连续流，该输入执行一些处理，并产生数据的连续流，以输出主题。<br>例如，零售应用程序可能需要在销售和出货量和输出的输入流计算关闭此数据重新排序和价格调整的流。<br>这是可以做到的简单处理直接使用生产者和消费者的API。然而，对于更复杂的转换kafka提供了一个完全集成的流API。这允许做不平凡的处理建筑应用程序，计算聚合过流或加入流在一起。<br>该设施有助于解决难题这种类型的应用面的：在处理乱序的数据，再处理输入作为代码的变化，执行有状态的计算等<br>API建立在芯中的基元流提供kafka：它使用用于输入的生产者和消费者的API，使用kafka有状态存储，并使用流处理器实例之间容错同一组的机制。</p>
<p>参考文章：<br>    官文：<a href="http://kafka.apache.org/intro" target="_blank" rel="external">Introduction to Kafka</a>。<br>    <a href="http://blog.jobbole.com/75328/" target="_blank" rel="external">分布式消息系统Kafka</a>。<br>    <a href="http://www.infoq.com/cn/articles/kafka-analysis-part-1/" target="_blank" rel="external">Kafka背景及架构介绍</a>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/10/Jwt-介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谢晖">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="谢晖的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/10/Jwt-介绍/" itemprop="url">
                  Jwt 介绍
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-10T22:08:49+08:00">
                2017-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全认证/" itemprop="url" rel="index">
                    <span itemprop="name">安全认证</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/10/Jwt-介绍/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/10/Jwt-介绍/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Jwt是什么"><a href="#Jwt是什么" class="headerlink" title="Jwt是什么?"></a>Jwt是什么?</h1><p>   Jwt的全称是JSON Web Token（<a href="http://www.jwt.io" target="_blank" rel="external">JWT</a>）是一种开放标准（RFC 7519），它定义了一种紧凑且独立的方式，用于将各方之间的信息安全地传输为JSON对象。 该信息可以通过数字签名进行验证和信任。 使用加密（使用HMAC算法）或使用RSA的公钥/私钥对可以对JWT进行签名。</p>
<p> Jwt特点：</p>
<ul>
<li><strong>紧凑</strong>: 因为它们的尺寸较小，所以JWTs可以通过URL，POST参数，或HTTP报头内发送。此外，较小的尺寸意味着传输速度快。</li>
<li><strong>自包含</strong>: 负载中包含了所有用户所需要的信息，避免了需要多次查询数据库。</li>
</ul>
<h1 id="什么时候使用Jwt"><a href="#什么时候使用Jwt" class="headerlink" title="什么时候使用Jwt?"></a>什么时候使用Jwt?</h1><p>下面是一些Jwt的应用场景：</p>
<ul>
<li><strong>身份认证(Authentication)</strong>: 这是使用JWT最常见的场景。一旦用户登录，每个后续请求将包括JWT，让用户的接入路径，服务和资源被允许使用该令牌。单点登录是在不同的领域很容易使用的广泛使用JWT如今，由于其小的开销和它的能力的特性。</li>
<li><strong>信息交换</strong>: Jwt是在各方之间安全传输信息的好方法，因为它们可以被签名，例如使用公钥/私钥对，您可以确定发件人是谁。 另外，当使用标题和有效载荷计算签名时，您还可以验证内容是否未被篡改。</li>
</ul>
<h1 id="Jwt数据结构"><a href="#Jwt数据结构" class="headerlink" title="Jwt数据结构?"></a>Jwt数据结构?</h1><p>一个Jwt实际上是由以下三个部分组成：</p>
<ul>
<li><p>header（头    部）:</p>
<ul>
<li><p>在header中通常包含了两部分：token类型和采用的加密算法。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;alg&quot;: &quot;HS256&quot;, //加密算法</div><div class="line">    &quot;typ&quot;: &quot;JWT&quot; //token 类型</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>- 接下来对这部分内容使用 Base64Url 编码组成了JWT结构的第一部分。
</code></pre><ul>
<li><p>payload（载荷） :</p>
<ul>
<li>Token的第二部分是负载，它包含了claim， Claim是一些实体（通常指的用户）的状态和额外的元数据，有三种类型的claim： reserved , public 和 private .</li>
<li>Reserved claims: 这些claim是JWT预先定义的，在JWT中并不会强制使用它们，而是推荐使用，常用的有 iss（签发者） , exp（过期时间戳） , sub（面向的用户） , aud（接收方） , iat（签发时间） 。</li>
<li>Public claims：根据需要定义自己的字段，注意应该避免冲突。</li>
<li><p>Private claims：这些是自定义的字段，可以用来在双方之间交换信息。</p>
<p>负载使用的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</div><div class="line">  &quot;name&quot;: &quot;John Doe&quot;,</div><div class="line">  &quot;admin&quot;: true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>signature（签名） ：</p>
<p>创建签名需要使用编码后的header和payload以及一个秘钥，使用header中指定签名算法进行签名。例如如果希望使用HMAC SHA256算法，那么签名应该使用下列方式创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">HMACSHA256(</div><div class="line"> base64UrlEncode(header) + &quot;.&quot; +</div><div class="line"> base64UrlEncode(payload),</div><div class="line"> secret)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>  签名用于验证消息的发送者以及消息是没有经过篡改的。</p>
<ul>
<li>完整的JWT</li>
</ul>
<p>JWT格式的输出是以 . 分隔的三段Base64编码，与SAML等基于XML的标准相比，JWT在HTTP和HTML环境中更容易传递。</p>
<p>下列的JWT展示了一个完整的JWT格式，它拼接了之前的Header， Payload以及秘钥签名：</p>
<p><img src="https://cdn.auth0.com/content/jwt/encoded-jwt3.png" alt="jwt"></p>
<h1 id="如何使用JWT？"><a href="#如何使用JWT？" class="headerlink" title="如何使用JWT？"></a>如何使用JWT？</h1><p>在身份鉴定的实现中，传统方法是在服务端存储一个session，给客户端返回一个cookie，而使用JWT之后，当用户使用它的认证信息登陆系统之后，会返回给用户一个JWT，用户只需要本地保存该token（通常使用local storage，也可以使用cookie）即可。</p>
<p>当用户希望访问一个受保护的路由或者资源的时候，通常应该在 Authorization 头部使用 Bearer 模式添加JWT，其内容看起来是下面这样：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Authorization: Bearer &lt;token&gt;</div></pre></td></tr></table></figure>
<p>因为用户的状态在服务端的内存中是不存储的，所以这是一种 无状态 的认证机制。服务端的保护路由将会检查请求头 Authorization 中的JWT信息，如果合法，则允许用户的行为。由于JWT是自包含的，因此减少了需要查询数据库的需要。</p>
<p>JWT的这些特性使得我们可以完全依赖其无状态的特性提供数据API服务，甚至是创建一个下载流服务。因为JWT并不使用Cookie的，所以你可以使用任何域名提供你的API服务而不需要担心跨域资源共享问题（CORS）。</p>
<p>下面的序列图展示了该过程：</p>
<p><img src="https://cdn.auth0.com/content/jwt/jwt-diagram.png" alt="jwt"></p>
<h1 id="为什么要使用JWT？"><a href="#为什么要使用JWT？" class="headerlink" title="为什么要使用JWT？"></a>为什么要使用JWT？</h1><p>相比XML格式，JSON更加简洁，编码之后更小，这使得JWT比SAML更加简洁，更加适合在HTML和HTTP环境中传递。</p>
<p>在安全性方面，SWT只能够使用HMAC算法和共享的对称秘钥进行签名，而JWT和SAML token则可以使用X.509认证的公私秘钥对进行签名。与简单的JSON相比，XML和XML数字签名会引入复杂的安全漏洞。</p>
<p>因为JSON可以直接映射为对象，在大多数编程语言中都提供了JSON解析器，而XML则没有这么自然的文档-对象映射关系，这就使得使用JWT比SAML更方便。</p>
<p>原文： <a href="https://jwt.io/introduction/" target="_blank" rel="external">Introduction to JSON Web Tokens</a>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/me.jpg"
               alt="谢晖" />
          <p class="site-author-name" itemprop="name">谢晖</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">谢晖</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  








  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  

    
      <script id="dsq-count-scr" src="https://coderpreacher.disqus.com.disqus.com/count.js" async></script>
    

    

  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.0"></script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.0"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.0"></script>


  
  <script type="text/javascript" src="/js/src/exturl.js?v=5.1.0"></script>


</body>
</html>
