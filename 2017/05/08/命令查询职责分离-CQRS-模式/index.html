<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>命令查询职责分离(CQRS)模式 | coderPreacher&#39;s Blog | Love life, love technology, positive, optimistic, beyond the self</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="CQRS">
    <meta name="description" content="背景和问题在传统的数据管理系统中，两个命令（对数据的更新）和查询（对数据的请求）都是针对单个数据存储库中的同一组实体执行的。 这些实体可以是关系数据库（如SQL Server）中一个或多个表中的行的子集。 通常在这些系统中，所有创建，读取，更新和删除（CRUD）操作都应用于实体的相同表示形式。 例如，通过数据访问层（DAL）从数据存储器检索表示客户的数据传输对象（DTO）并显示在屏幕上。 用户更新">
<meta name="keywords" content="CQRS">
<meta property="og:type" content="article">
<meta property="og:title" content="命令查询职责分离(CQRS)模式">
<meta property="og:url" content="http://coderpreacher.top/2017/05/08/命令查询职责分离-CQRS-模式/index.html">
<meta property="og:site_name" content="coderPreacher's Blog">
<meta property="og:description" content="背景和问题在传统的数据管理系统中，两个命令（对数据的更新）和查询（对数据的请求）都是针对单个数据存储库中的同一组实体执行的。 这些实体可以是关系数据库（如SQL Server）中一个或多个表中的行的子集。 通常在这些系统中，所有创建，读取，更新和删除（CRUD）操作都应用于实体的相同表示形式。 例如，通过数据访问层（DAL）从数据存储器检索表示客户的数据传输对象（DTO）并显示在屏幕上。 用户更新">
<meta property="og:image" content="https://docs.microsoft.com/en-us/azure/architecture/patterns/_images/command-and-query-responsibility-segregation-cqrs-tradition-crud.png">
<meta property="og:image" content="https://docs.microsoft.com/en-us/azure/architecture/patterns/_images/command-and-query-responsibility-segregation-cqrs-basic.png">
<meta property="og:image" content="https://docs.microsoft.com/en-us/azure/architecture/patterns/_images/command-and-query-responsibility-segregation-cqrs-separate-stores.png">
<meta property="og:image" content="https://www.codeproject.com/KB/architecture/555855/QuerySide.jpg">
<meta property="og:image" content="https://www.codeproject.com/KB/architecture/555855/CommandSide.jpg">
<meta property="og:image" content="https://www.codeproject.com/KB/architecture/555855/CQRS.jpg">
<meta property="og:image" content="http://images.cnitblog.com/blog/94031/201408/261851449547571.png">
<meta property="og:updated_time" content="2017-05-09T01:05:45.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="命令查询职责分离(CQRS)模式">
<meta name="twitter:description" content="背景和问题在传统的数据管理系统中，两个命令（对数据的更新）和查询（对数据的请求）都是针对单个数据存储库中的同一组实体执行的。 这些实体可以是关系数据库（如SQL Server）中一个或多个表中的行的子集。 通常在这些系统中，所有创建，读取，更新和删除（CRUD）操作都应用于实体的相同表示形式。 例如，通过数据访问层（DAL）从数据存储器检索表示客户的数据传输对象（DTO）并显示在屏幕上。 用户更新">
<meta name="twitter:image" content="https://docs.microsoft.com/en-us/azure/architecture/patterns/_images/command-and-query-responsibility-segregation-cqrs-tradition-crud.png">
    
        <link rel="alternate" type="application/atom+xml" title="coderPreacher&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/images/me.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">谢晖</h5>
          <a href="mailto:coderpreacher@gmail.com" title="coderpreacher@gmail.com" class="mail">coderpreacher@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">命令查询职责分离(CQRS)模式</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">命令查询职责分离(CQRS)模式</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-05-08T13:08:30.000Z" itemprop="datePublished" class="page-time">
  2017-05-08
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Design-Patterns/">Design Patterns</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#背景和问题"><span class="post-toc-number">1.</span> <span class="post-toc-text">背景和问题</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#解决方案CQRS"><span class="post-toc-number">2.</span> <span class="post-toc-text">解决方案CQRS</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#CQRS介绍"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">CQRS介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#查询端-Query-side"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">查询端(Query side)</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#命令端-Command-side"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">命令端(Command side)</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#为什么要使用CQRS？"><span class="post-toc-number">3.</span> <span class="post-toc-text">为什么要使用CQRS？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#可扩展性"><span class="post-toc-number">3.0.1.</span> <span class="post-toc-text">可扩展性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#降低复杂性"><span class="post-toc-number">3.0.2.</span> <span class="post-toc-text">降低复杂性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#灵活性"><span class="post-toc-number">3.0.3.</span> <span class="post-toc-text">灵活性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#专注于业务"><span class="post-toc-number">3.0.4.</span> <span class="post-toc-text">专注于业务</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#有利于构建基于任务的用户界面"><span class="post-toc-number">3.0.5.</span> <span class="post-toc-text">有利于构建基于任务的用户界面</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#什么时候可以考虑CQRS"><span class="post-toc-number">4.</span> <span class="post-toc-text">什么时候可以考虑CQRS</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#CQRS的简单实现"><span class="post-toc-number">5.</span> <span class="post-toc-text">CQRS的简单实现</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Query端的实现"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">Query端的实现</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Command端实现"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">Command端实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#总结"><span class="post-toc-number">6.</span> <span class="post-toc-text">总结</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-命令查询职责分离-CQRS-模式"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">命令查询职责分离(CQRS)模式</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-05-08 21:08:30" datetime="2017-05-08T13:08:30.000Z"  itemprop="datePublished">2017-05-08</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Design-Patterns/">Design Patterns</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="背景和问题"><a href="#背景和问题" class="headerlink" title="背景和问题"></a>背景和问题</h1><p>在传统的数据管理系统中，两个命令（对数据的更新）和查询（对数据的请求）都是针对单个数据存储库中的同一组实体执行的。 这些实体可以是关系数据库（如SQL Server）中一个或多个表中的行的子集。</p>
<p>通常在这些系统中，所有创建，读取，更新和删除（CRUD）操作都应用于实体的相同表示形式。 例如，通过数据访问层（DAL）从数据存储器检索表示客户的数据传输对象（DTO）并显示在屏幕上。 用户更新DTO的某些字段（可能通过数据绑定），然后DTO将由DAL保存回数据存储。 同样的DTO用于读写操作。 该图说明了传统的CRUD架构。</p>
<p><img src="https://docs.microsoft.com/en-us/azure/architecture/patterns/_images/command-and-query-responsibility-segregation-cqrs-tradition-crud.png" alt="crud"></p>
<p>当只有有限的业务逻辑应用于数据操作时，传统的CRUD设计才能正常运行。开发工具提供的支架机制可以非常快速地创建数据访问代码，然后可以根据需要进行自定义。<br>然而，传统的CRUD方法有一些缺点：</p>
<ul>
<li>这通常意味着数据的读取和写入表示之间存在不匹配的情况，例如即使不需要作为操作的一部分，必须正确更新的附加列或属性。</li>
<li>当记录被锁定在协作域中的数据存储中时，数据争用就会发生风险，其中多个角色在同一组数据上并行操作。或者当使用乐观锁定时更新由并发更新引起的冲突。随着系统的复杂性和吞吐量的增加，这些风险将增加。此外，由于数据存储和数据访问层的负载以及检索信息所需的查询的复杂性，传统的方法可能会对性能产生负面影响。</li>
<li>它可以使管理安全和权限更加复杂，因为每个实体都受到读写操作的限制，这可能会在错误的上下文中暴露数据。</li>
<li>同步的，直接与数据库进行交互在大数据量同时访问的情况下可能会影响性能和响应性，并且可能会产生性能瓶颈。</li>
</ul>
<h1 id="解决方案CQRS"><a href="#解决方案CQRS" class="headerlink" title="解决方案CQRS"></a>解决方案CQRS</h1><h2 id="CQRS介绍"><a href="#CQRS介绍" class="headerlink" title="CQRS介绍"></a>CQRS介绍</h2><p>CQRS表示命令查询责任分离。 许多人认为CQRS是整个架构，但它们是错误的。 CQRS只是一个小小的模式。 这种模式首先由Greg Young和Udi Dahan介绍。 他们从Bertrand Meyer在“面向对象软件构建”一书中定义的命令查询分离模式中获得灵感。 CQS背后的主要思想是：“一个方法应该改变一个对象的状态，或者返回一个结果，而不是两者。 换句话说，问问题不应该改变答案。 更正式地，如果方法透明，那么方法应该返回一个值，因此没有副作用。“（维基百科）因此，我们可以将方法分为两组：</p>
<ul>
<li>Commands：更改对象或整个系统的状态（有时称为修饰符或变体）。</li>
<li>Queries：返回结果，不要更改对象的状态。</li>
</ul>
<p>命令和查询责任分离（CQRS）是一种模式，它通过使用单独的接口来隔离从更新数据（命令）的操作中读取数据（查询）的操作。 这意味着用于查询和更新的数据模型是不同的。 然后，可以隔离模型，如下图所示，尽管这不是绝对要求。<br><img src="https://docs.microsoft.com/en-us/azure/architecture/patterns/_images/command-and-query-responsibility-segregation-cqrs-basic.png" alt="cqrs2"></p>
<p>与基于CRUD的系统中使用的单一数据模型相比，在基于CQRS的系统中使用单独的查询和更新模型来简化设计和实现。 然而，一个缺点是与CRUD设计不同，CQRS代码不能使用脚手架机制自动生成。<br>用于读取数据的查询模型和用于写入数据的更新模型可以访问相同的物理存储，也许通过使用SQL视图或通过快速生成投影。 然而，通常将数据分成不同的物理存储，以最大限度地提高性能，可扩展性和安全性，如下图所示。</p>
<p><img src="https://docs.microsoft.com/en-us/azure/architecture/patterns/_images/command-and-query-responsibility-segregation-cqrs-separate-stores.png" alt="cqrs3"></p>
<p>读存储可以是写存储的只读副本，或者读写存储可以具有不同的结构。 使用读取存储器的多个只读副本可以大大提高查询性能和应用程序UI响应性，特别是在只读副本位于靠近应用程序实例的分布式场景中。 某些数据库系统（SQL Server）提供了其他功能，例如故障转移副本，以最大限度地提高可用性。<br>读写存储器的分离还允许每个存储器被适当地缩放以匹配负载。 例如，读取存储器通常会遇到比写入存储器高得多的负载。</p>
<p>在一个真实的情况下，很简单的告诉哪个是哪个。查询将声明返回类型，命令将返回void。这种模式是广泛适用的，它使得关于对象的推理更容易。另一方面，CQRS仅适用于具体问题。</p>
<p>使用主流方法的许多应用程序都由读写方面常见的模型组成。拥有相同的读写方式可以导致更为复杂的模型，难以维护和优化。</p>
<p>这两种模式的真正实力就是你可以分开改变状态的方法。在处理性能和调优的情况下，这种分离可能非常方便。您可以从写入端分开优化系统的读取端。写方面被称为域。域包含所有行为。阅读方面专门针对报告需求。</p>
<p>这种模式的另一个好处是在大量应用的情况下。您可以将开发人员拆分为在系统不同方面工作的较小团队（读或写），而不了解对方。例如，在阅读方面工作的开发人员不需要了解域模型。</p>
<h2 id="查询端-Query-side"><a href="#查询端-Query-side" class="headerlink" title="查询端(Query side)"></a>查询端(Query side)</h2><p>这些查询只会包含获取数据的方法。 从架构的角度来看，这些将是返回客户端在屏幕上显示的DTO的所有方法。 DTO通常是域对象的预测。 在某些情况下，这可能是一个非常痛苦的过程，特别是当需要复杂的DTO时。</p>
<p>使用CQRS可以避免这些预测。 相反，可以引入一种新的投资DTO的方法。 您可以绕过域模型，并使用读取层从数据存储中直接获取DTO。 当应用程序正在请求数据时，可以通过单次调用读取层来完成此操作，该层返回包含所有所需数据的单个DTO。<br><img src="https://www.codeproject.com/KB/architecture/555855/QuerySide.jpg" alt="q1"></p>
<p>读取层可以直接连接到数据库（数据模型），而使用存储过程来读取数据并不是个好主意。 与数据源的直接连接通过维护和优化使查询变得非常简单。 非正规化数据是有道理的。 这样做的原因是数据通常被查询是执行域行为的多倍。 这种非规范化可能会提高应用程序的性能。</p>
<h2 id="命令端-Command-side"><a href="#命令端-Command-side" class="headerlink" title="命令端(Command side)"></a>命令端(Command side)</h2><p>由于读取端已被分离，因此域仅专注于处理命令。 现在域对象不再需要暴露内部状态。 存储库除了GetById之外只有几种查询方法。</p>
<p><img src="https://www.codeproject.com/KB/architecture/555855/CommandSide.jpg" alt="CommandSide"></p>
<p>命令由客户端应用程序创建，然后发送到域层。 命令是指示特定实体执行某些操作的消息。 命令命名为DoSomething（例如ChangeName，DeleteOrder …）。 他们指示目标实体做某些可能导致不同结果或失败的事情。 命令由命令处理程序处理。</p>
<h1 id="为什么要使用CQRS？"><a href="#为什么要使用CQRS？" class="headerlink" title="为什么要使用CQRS？"></a>为什么要使用CQRS？</h1><p>从CQRS回退一段时间，将域分为DDD中的有界环境的好处之一是使您能够识别并集中于系统更复杂的部分（有界环境），受到不断变化的业务 规则或提供作为关键业务差异化的功能。<br>只有在提供可识别的业务收益的情况下，才应考虑将CQRS模式应用于特定有限的上下文，而不是因为它是您考虑的默认模式。<br>您可以通过应用CQRS模式获得的最常见的业务优势是增强的可扩展性，简化您的域的复杂方面，提高解决方案的灵活性，以及更好地适应不断变化的业务需求。</p>
<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>在许多企业系统中，读取次数大大超过了写入次数，因此您的可扩展性要求在每一方面都会有所不同。通过将读取端和写入端分隔为有界环境中的单独模型，您现在可以独立地对每个模型进行扩展。例如，如果您在Microsoft Azure中托管应用程序，则可以为每一方使用不同的角色，然后通过向每个角色添加不同数量的角色实例来独立扩展它们。<br>可扩展性不应该是您在特定有限上下文中选择实施CQRS模式的唯一原因：<br>“在非协作域中，您可以在其中添加更多的数据库服务器来支持更多用户，请求和数据，同时添加Web服务器，但没有真正的可伸缩性问题（直到您的大小为Amazon，Google或Facebook）。如果您使用MySQL，SQL Server Express或其他数据库服务器，数据库服务器可以便宜。</p>
<h3 id="降低复杂性"><a href="#降低复杂性" class="headerlink" title="降低复杂性"></a>降低复杂性</h3><p>在您的领域的复杂领域，设计和实现负责读取和写入数据的对象可能会加剧复杂性。在许多情况下，复杂的业务逻辑仅在系统处理更新和事务操作时应用;相比之下，读逻辑往往要简单得多。当业务逻辑和读逻辑在同一模型中混合在一起时，处理诸如多用户，共享数据，性能，事务，一致性和过时数据等困难问题变得更加困难。将读取的逻辑和业务逻辑分成单独的模型可以更容易地分离和解决这些复杂的问题。然而，在许多情况下，可能需要一些努力来解开和了解域中现有的模型。<br>分离问题是Bertrand Meyer的命令查询分离原则背后的关键动机：<br>“这个原则中真正有价值的想法是，如果您能够清楚地将状态与不改变状态的方法分开，这是非常有用的，这是因为您可以在许多情况下使用查询更有信心，在任何地方介绍它们，你必须更加小心修饰符。“<br>-Martin Fowler，CommandQuerySeparation<br>像许多模式一样，您可以将CQRS模式视为将您领域中固有的一些复杂性转化为众所周知的知识，并为解决某些类别问题提供了一种标准方法。<br>通过分离读取逻辑和业务逻辑来简化有界环境的另一个潜在好处是它可以使测试更容易。</p>
<h3 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a>灵活性</h3><p>使用CQRS模式的解决方案的灵活性主要来自于分离到读取端和写入端模型。在读取方面进行更改变得更加容易，例如在您可以确信不会对业务逻辑的行为产生任何影响的情况下添加新的查询来支持UI中的新的报告屏幕。在写作方面，拥有一个仅关心域内核心业务逻辑的模型意味着您拥有一个比包含读取逻辑的模型更简单的模型来处理。<br>从长远来看，一个准确描述您的核心域业务逻辑的良好有用的模型将成为宝贵的资产。面对不断变化的商业环境和对您的组织的竞争压力，这将使您更加敏捷。<br>这种灵活性和敏捷性与DDD中持续集成的概念有关：<br>“持续整合意味着在上下文中的所有工作正在被合并并且变得足够一致，当分裂发生时，它们被快速地捕获和纠正。<br>在某些情况下，可能有不同的开发团队在写作方面和阅读方面工作，但实际上这可能取决于特定有界上下文的大小。</p>
<h3 id="专注于业务"><a href="#专注于业务" class="headerlink" title="专注于业务"></a>专注于业务</h3><p>如果您使用像CRUD这样的方法，那么该技术往往会塑造解决方案。 采用CQRS模式有助于您专注于业务和构建面向任务的UI。 将不同问题分解为读取端和写入端的结果是在面对不断变化的业务需求时更适应的解决方案。 这导致较长的开发和维护成本较低。</p>
<h3 id="有利于构建基于任务的用户界面"><a href="#有利于构建基于任务的用户界面" class="headerlink" title="有利于构建基于任务的用户界面"></a>有利于构建基于任务的用户界面</h3><p>当您实现CQRS模式时，您可以使用命令（通常来自UI）来启动域中的操作。 这些命令通常与域操作和无处不在的语言密切相关。 例如，“为X会议预订两个座位” 您可以设计UI以将这些命令发送到域，而不是启动CRUD风格的操作。 这使得更容易设计直观的基于任务的UI。</p>
<h1 id="什么时候可以考虑CQRS"><a href="#什么时候可以考虑CQRS" class="headerlink" title="什么时候可以考虑CQRS"></a>什么时候可以考虑CQRS</h1><p>CQRS模式有一些优点：</p>
<ol>
<li>分工明确，可以负责不同的部分</li>
<li>将业务上的命令和查询的职责分离能够提高系统的性能、可扩展性和安全性。并且在系统的演化中能够保持高度的灵活性，能够防止出现CRUD模式中，对查询或者修改中的某一方进行改动，导致另一方出现问题的情况。</li>
<li>逻辑清晰，能够看到系统中的那些行为或者操作导致了系统的状态变化。</li>
<li>可以从数据驱动(Data-Driven) 转到任务驱动(Task-Driven)以及事件驱动(Event-Driven).</li>
</ol>
<p>在下场景中，可以考虑使用CQRS模式：</p>
<ol>
<li>当在业务逻辑层有很多操作需要相同的实体或者对象进行操作的时候。CQRS使得我们可以对读和写定义不同的实体和方法，从而可以减少或者避免对某一方面的更改造成冲突</li>
<li>对于一些基于任务的用户交互系统，通常这类系统会引导用户通过一系列复杂的步骤和操作，通常会需要一些复杂的领域模型，并且整个团队已经熟悉领域驱动设计技术。写模型有很多和业务逻辑相关的命令操作的堆，输入验证，业务逻辑验证来保证数据的一致性。读模型没有业务逻辑以及验证堆，仅仅是返回DTO对象为视图模型提供数据。读模型最终和写模型相一致。</li>
<li>适用于一些需要对查询性能和写入性能分开进行优化的系统，尤其是读/写比非常高的系统，横向扩展是必须的。比如，在很多系统中读操作的请求时远大于写操作。为适应这种场景，可以考虑将写模型抽离出来单独扩展，而将写模型运行在一个或者少数几个实例上。少量的写模型实例能够减少合并冲突发生的情况</li>
<li>适用于一些团队中，一些有经验的开发者可以关注复杂的领域模型，这些用到写操作，而另一些经验较少的开发者可以关注用户界面上的读模型。</li>
<li>对于系统在将来会随着时间不段演化，有可能会包含不同版本的模型，或者业务规则经常变化的系统</li>
<li><p>需要和其他系统整合，特别是需要和事件溯源Event Sourcing进行整合的系统，这样子系统的临时异常不会影响整个系统的其他部分。<br>但是在以下场景中，可能不适宜使用CQRS：</p>
</li>
<li><p>领域模型或者业务逻辑比较简单，这种情况下使用CQRS会把系统搞复杂。</p>
</li>
<li>对于简单的，CRUD模式的用户界面以及与之相关的数据访问操作已经足够的话，没必要使用CQRS，这些都是一个简单的对数据进行增删改查。</li>
<li>不适合在整个系统中到处使用该模式。在整个数据管理场景中的特定模块中CQRS可能比较有用。但是在有些地方使用CQRS会增加系统不必要的复杂性。</li>
</ol>
<h1 id="CQRS的简单实现"><a href="#CQRS的简单实现" class="headerlink" title="CQRS的简单实现"></a>CQRS的简单实现</h1><p>CQRS模式在思想上比较简单，但是实现上还是有些复杂。它涉及到DDD，以及Event Sourcing，这里使用codeproject上的 <a href="https://www.codeproject.com/Articles/555855/Introduction-to-CQRS" target="_blank" rel="external">Introduction to CQRS</a> 这篇文章的例子来说明CQRS模式。这个例子是一个简单的在线记日志(Diary)系统，实现了日志的增删改查功能。整体结构如下：<br><img src="https://www.codeproject.com/KB/architecture/555855/CQRS.jpg" alt="cqrs"></p>
<p>上图很清晰的说明了CQRS在读写方面的分离，在读方面，通过QueryFacade到数据库里去读取数据，这个库有可能是ReportingDB。在写方面，比较复杂，操作通过Command发送到CommandBus上，然后特定的CommandHandler处理请求，产生对应的Event，将Eevnt持久化后，通过EventBus特定的EevntHandler对数据库进行修改等操作。</p>
<p>例子代码可以到<a href="https://www.codeproject.com/Articles/555855/Introduction-to-CQRS" target="_blank" rel="external">codeproject</a>上下载，整体结构如下：<br><img src="http://images.cnitblog.com/blog/94031/201408/261851449547571.png" alt="PROJECT"><br>由三个项目构成，Diary.CQRS包含了所有的Domain和消息对象。Configuration通过使用一个名为StructMap的IOC来初始化一些变量方便Web调用，Web是一个简单的MVC3项目，在Controller中有与CQRS交互的代码。</p>
<p>下面分别看Query和Command方面的实现：</p>
<h2 id="Query端的实现"><a href="#Query端的实现" class="headerlink" title="Query端的实现"></a>Query端的实现</h2><p>查询方面很简单，日志列表和明细获取就是简单的查询。下面先看列表查询部分的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public ActionResult Index()</div><div class="line">&#123;</div><div class="line">    ViewBag.Model = ServiceLocator.ReportDatabase.GetItems();</div><div class="line">    return View();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public ActionResult Edit(Guid id)</div><div class="line">&#123;</div><div class="line">    var item = ServiceLocator.ReportDatabase.GetById(id);</div><div class="line">    var model = new DiaryItemDto()</div><div class="line">    &#123;</div><div class="line">        Description = item.Description,</div><div class="line">        From = item.From,</div><div class="line">        Id = item.Id,</div><div class="line">        Title = item.Title,</div><div class="line">        To = item.To,</div><div class="line">        Version = item.Version</div><div class="line">    &#125;;</div><div class="line">    return View(model);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ReportDatabase的GetItems和GetById(id)方法就是简单的查询，从命名可以看出他是ReportDatabase。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class ReportDatabase : IReportDatabase</div><div class="line">&#123;</div><div class="line">    static List&lt;DiaryItemDto&gt; items = new List&lt;DiaryItemDto&gt;();</div><div class="line"></div><div class="line">    public DiaryItemDto GetById(Guid id)</div><div class="line">    &#123;</div><div class="line">        return items.Where(a =&gt; a.Id == id).FirstOrDefault();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void Add(DiaryItemDto item)</div><div class="line">    &#123;</div><div class="line">        items.Add(item);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void Delete(Guid id)</div><div class="line">    &#123;</div><div class="line">        items.RemoveAll(i =&gt; i.Id == id);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public List&lt;DiaryItemDto&gt; GetItems()</div><div class="line">    &#123;</div><div class="line">        return items;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ReportDataBase只是在内部维护了一个List的DiaryItemDto列表。在使用的时候，是通过IRepositoryDatabase对其进行操作的，这样便于mock代码。</p>
<p>Query端的代码很简单。在实际的应用中，这一块就是直接对DB进行查询，然后通过DTO对象返回，这个DB可能是应对特定场景的报表数据库，这样可以提升查询性能。</p>
<p>下面来看Command端的实现：</p>
<h2 id="Command端实现"><a href="#Command端实现" class="headerlink" title="Command端实现"></a>Command端实现</h2><p>Command的实现比较复杂，下面以简单的创建一个新的日志来说明。</p>
<p>在MVC的Control中，可以看到Add的Controller中只调用了一句话:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[HttpPost]</div><div class="line">public ActionResult Add(DiaryItemDto item)</div><div class="line">&#123;</div><div class="line">    ServiceLocator.CommandBus.Send(new CreateItemCommand(Guid.NewGuid(), item.Title, item.Description, -1, item.From, item.To));</div><div class="line"></div><div class="line">    return RedirectToAction(&quot;Index&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先声明了一个CreateItemCommand，这个Command只是保存了一些必要的信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class CreateItemCommand:Command</div><div class="line">&#123;</div><div class="line">    public string Title &#123; get; internal set; &#125;</div><div class="line">    public string Description &#123; get;internal set; &#125;</div><div class="line">    public DateTime From &#123; get; internal set; &#125;</div><div class="line">    public DateTime To &#123; get; internal set; &#125;</div><div class="line"></div><div class="line">    public CreateItemCommand(Guid aggregateId, string title, </div><div class="line">        string description,int version,DateTime from, DateTime to)</div><div class="line">        : base(aggregateId,version)</div><div class="line">    &#123;</div><div class="line">        Title = title;</div><div class="line">        Description = description;</div><div class="line">        From = from;</div><div class="line">        To = to;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后将Command发送到了CommandBus上，其实就是让CommandBus来选择合适的CommandHandler来处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class CommandBus:ICommandBus</div><div class="line">&#123;</div><div class="line">    private readonly ICommandHandlerFactory _commandHandlerFactory;</div><div class="line"></div><div class="line">    public CommandBus(ICommandHandlerFactory commandHandlerFactory)</div><div class="line">    &#123;</div><div class="line">        _commandHandlerFactory = commandHandlerFactory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void Send&lt;T&gt;(T command) where T : Command</div><div class="line">    &#123;</div><div class="line">        var handler = _commandHandlerFactory.GetHandler&lt;T&gt;();</div><div class="line">        if (handler != null)</div><div class="line">        &#123;</div><div class="line">            handler.Execute(command);</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            throw new UnregisteredDomainCommandException(&quot;no handler registered&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个里面需要值得注意的是CommandHandlerFactory这个类型的GetHandler方法，他接受一个类型为T的泛型，这里就是我们之前传入的CreateItemCommand。来看他的GetHandler方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class StructureMapCommandHandlerFactory : ICommandHandlerFactory</div><div class="line">&#123;</div><div class="line">    public ICommandHandler&lt;T&gt; GetHandler&lt;T&gt;() where T : Command</div><div class="line">    &#123;</div><div class="line">        var handlers = GetHandlerTypes&lt;T&gt;().ToList();</div><div class="line"></div><div class="line">        var cmdHandler = handlers.Select(handler =&gt; </div><div class="line">            (ICommandHandler&lt;T&gt;)ObjectFactory.GetInstance(handler)).FirstOrDefault();</div><div class="line"></div><div class="line">        return cmdHandler;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private IEnumerable&lt;Type&gt; GetHandlerTypes&lt;T&gt;() where T : Command</div><div class="line">    &#123;</div><div class="line">        var handlers = typeof(ICommandHandler&lt;&gt;).Assembly.GetExportedTypes()</div><div class="line">            .Where(x =&gt; x.GetInterfaces()</div><div class="line">                .Any(a =&gt; a.IsGenericType &amp;&amp; a.GetGenericTypeDefinition() == typeof(ICommandHandler&lt;&gt;) ))</div><div class="line">                .Where(h=&gt;h.GetInterfaces()</div><div class="line">                    .Any(ii=&gt;ii.GetGenericArguments()</div><div class="line">                        .Any(aa=&gt;aa==typeof(T)))).ToList();</div><div class="line"></div><div class="line"></div><div class="line">        return handlers;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里可以看到，他首先查找当前的程序集中(ICommandHandler)所在的程序集中的所有的实现了ICommandHandler的接口的类型，然后在所有的类型找查找实现了该泛型接口并且泛型的类型参数类型为T类型的所有类型。以上面的代码为例，就是要找出实现了ICommandHandler<createitemcommand>接口的类型。可以看到就是CreateItemCommandHandler类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class CreateItemCommandHandler : ICommandHandler&lt;CreateItemCommand&gt;</div><div class="line">&#123;</div><div class="line">    private IRepository&lt;DiaryItem&gt; _repository;</div><div class="line"></div><div class="line">    public CreateItemCommandHandler(IRepository&lt;DiaryItem&gt; repository)</div><div class="line">    &#123;</div><div class="line">        _repository = repository;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void Execute(CreateItemCommand command)</div><div class="line">    &#123;</div><div class="line">        if (command == null)</div><div class="line">        &#123;</div><div class="line">            throw new ArgumentNullException(&quot;command&quot;);</div><div class="line">        &#125;</div><div class="line">        if (_repository == null)</div><div class="line">        &#123;</div><div class="line">            throw new InvalidOperationException(&quot;Repository is not initialized.&quot;);</div><div class="line">        &#125;</div><div class="line">        var aggregate = new DiaryItem(command.Id, command.Title, command.Description, command.From, command.To);</div><div class="line">        aggregate.Version = -1;</div><div class="line">        _repository.Save(aggregate, aggregate.Version);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></createitemcommand></p>
<p>找到之后然后使用IOC实例化了该对象返回。</p>
<p>现在CommandBus中，找到了处理特定Command的Handler。然后执行该类型的Execute方法。</p>
<p>可以看到在该类型中实例化了一个名为aggregate的DiaryItem对象。这个和我们之前查询所用到的DiaryItemDto有所不同，这个一个领域对象，里面包含了一系列事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public class DiaryItem : AggregateRoot, </div><div class="line">    IHandle&lt;ItemCreatedEvent&gt;,</div><div class="line">    IHandle&lt;ItemRenamedEvent&gt;,</div><div class="line">    IHandle&lt;ItemFromChangedEvent&gt;, </div><div class="line">    IHandle&lt;ItemToChangedEvent&gt;,</div><div class="line">    IHandle&lt;ItemDescriptionChangedEvent&gt;,</div><div class="line">    IOriginator</div><div class="line">&#123;</div><div class="line">    public string Title &#123; get; set; &#125;</div><div class="line"></div><div class="line">    public DateTime From &#123; get; set; &#125;</div><div class="line">    public DateTime To &#123; get; set; &#125;</div><div class="line">    public string Description &#123; get; set; &#125;</div><div class="line"></div><div class="line">    public DiaryItem()</div><div class="line">    &#123; </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public DiaryItem(Guid id,string title, string description,  DateTime from, DateTime to)</div><div class="line">    &#123;</div><div class="line">        ApplyChange(new ItemCreatedEvent(id, title,description, from, to));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void ChangeTitle(string title)</div><div class="line">    &#123;</div><div class="line">        ApplyChange(new ItemRenamedEvent(Id, title));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void Handle(ItemCreatedEvent e)</div><div class="line">    &#123;</div><div class="line">        Title = e.Title;</div><div class="line">        From = e.From;</div><div class="line">        To = e.To;</div><div class="line">        Id = e.AggregateId;</div><div class="line">        Description = e.Description;</div><div class="line">        Version = e.Version;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void Handle(ItemRenamedEvent e)</div><div class="line">    &#123;</div><div class="line">        Title = e.Title;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ItemCreatedEvent 事件的定义如下，其实就是用来存储传输过程中需要用到的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class ItemCreatedEvent:Event</div><div class="line">&#123;</div><div class="line">    public string Title &#123; get; internal set; &#125;</div><div class="line">    public DateTime From &#123; get; internal set; &#125;</div><div class="line">    public DateTime To &#123; get; internal set; &#125;</div><div class="line">    public string Description &#123; get;internal set; &#125;</div><div class="line"></div><div class="line">    public ItemCreatedEvent(Guid aggregateId, string title ,</div><div class="line">        string description, DateTime from, DateTime to)</div><div class="line">    &#123;</div><div class="line">        AggregateId = aggregateId;</div><div class="line">        Title = title;</div><div class="line">        From = from;</div><div class="line">        To = to;</div><div class="line">        Description = description;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到在Domain对象中，除了定义基本的字段外，还定义了一些相应的事件，比如在构造函数中，实际上是发起了一个名为ItemCreateEvent的事件，同时还定义了处理时间的逻辑，这些逻辑都放在名为Handle的接口方法发，例如ItemCerateEvent的处理方法为Handle(ItemCreateEvent)方法。</p>
<p>ApplyChange方法在AggregateRoot对象中，他是聚集根，这是DDD中的概念。通过这个根可以串起所有对象。 该类实现了IEventProvider接口，他保存了所有在_changes中的所有没有提交的变更，其中的ApplyChange的用来为特定的Event查找Eventhandler的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public abstract class AggregateRoot : IEventProvider</div><div class="line">&#123;</div><div class="line">    private readonly List&lt;Event&gt; _changes;</div><div class="line"></div><div class="line">    public Guid Id &#123; get; internal set; &#125;</div><div class="line">    public int Version &#123; get; internal set; &#125;</div><div class="line">    public int EventVersion &#123; get; protected set; &#125;</div><div class="line"></div><div class="line">    protected AggregateRoot()</div><div class="line">    &#123;</div><div class="line">        _changes = new List&lt;Event&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public IEnumerable&lt;Event&gt; GetUncommittedChanges()</div><div class="line">    &#123;</div><div class="line">        return _changes;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void MarkChangesAsCommitted()</div><div class="line">    &#123;</div><div class="line">        _changes.Clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void LoadsFromHistory(IEnumerable&lt;Event&gt; history)</div><div class="line">    &#123;</div><div class="line">        foreach (var e in history) ApplyChange(e, false);</div><div class="line">        Version = history.Last().Version;</div><div class="line">        EventVersion = Version;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void ApplyChange(Event @event)</div><div class="line">    &#123;</div><div class="line">        ApplyChange(@event, true);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void ApplyChange(Event @event, bool isNew)</div><div class="line">    &#123;</div><div class="line">        dynamic d = this;</div><div class="line"></div><div class="line">        d.Handle(Converter.ChangeTo(@event, @event.GetType()));</div><div class="line">        if (isNew)</div><div class="line">        &#123;</div><div class="line">            _changes.Add(@event);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在ApplyChange的实现中，this其实就是对应的实现了AggregateRoot的DiaryItem的Domain对象，调用的Handle方法就是我们之前在DiaryItem中定义的行为。然后将该event保存在内部的未提交的事件列表中。相关的信息及事件都保存在了定义的aggregate对象中并返回。</p>
<p>然后Command继续执行，然后调用了_repository.Save(aggregate, aggregate.Version);这个方法。先看这个Repository对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">public class Repository&lt;T&gt; : IRepository&lt;T&gt; where T : AggregateRoot, new()</div><div class="line">&#123;</div><div class="line">    private readonly IEventStorage _storage;</div><div class="line">    private static object _lockStorage = new object();</div><div class="line"></div><div class="line">    public Repository(IEventStorage storage)</div><div class="line">    &#123;</div><div class="line">        _storage = storage;</div><div class="line">    &#125; </div><div class="line"></div><div class="line">    public void Save(AggregateRoot aggregate, int expectedVersion)</div><div class="line">    &#123;</div><div class="line">        if (aggregate.GetUncommittedChanges().Any())</div><div class="line">        &#123;</div><div class="line">            lock (_lockStorage)</div><div class="line">            &#123;</div><div class="line">                var item = new T();</div><div class="line"></div><div class="line">                if (expectedVersion != -1)</div><div class="line">                &#123;</div><div class="line">                    item = GetById(aggregate.Id);</div><div class="line">                    if (item.Version != expectedVersion)</div><div class="line">                    &#123;</div><div class="line">                        throw new ConcurrencyException(string.Format(&quot;Aggregate &#123;0&#125; has been previously modified&quot;,</div><div class="line">                                                                        item.Id));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                _storage.Save(aggregate);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public T GetById(Guid id)</div><div class="line">    &#123;</div><div class="line">        IEnumerable&lt;Event&gt; events;</div><div class="line">        var memento = _storage.GetMemento&lt;BaseMemento&gt;(id);</div><div class="line">        if (memento != null)</div><div class="line">        &#123;</div><div class="line">            events = _storage.GetEvents(id).Where(e=&gt;e.Version&gt;=memento.Version);</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            events = _storage.GetEvents(id);</div><div class="line">        &#125;</div><div class="line">        var obj = new T();</div><div class="line">        if(memento!=null)</div><div class="line">            ((IOriginator)obj).SetMemento(memento);</div><div class="line"></div><div class="line">        obj.LoadsFromHistory(events);</div><div class="line">        return obj;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法主要是用来对事件进行持久化的。 所有的聚合的变动都会存在该Repository中，首先，检查当前的聚合是否和之前存储在storage中的聚合一致，如果不一致，则表示对象在其他地方被更改过，抛出ConcurrencyException，否则将该变动保存在Event Storage中。</p>
<p>IEventStorage用来存储所有的事件，其实现类型为InMemoryEventStorage。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">public class InMemoryEventStorage:IEventStorage</div><div class="line">&#123;</div><div class="line">    private List&lt;Event&gt; _events;</div><div class="line">    private List&lt;BaseMemento&gt; _mementos;</div><div class="line"></div><div class="line">    private readonly IEventBus _eventBus;</div><div class="line"></div><div class="line">    public InMemoryEventStorage(IEventBus eventBus)</div><div class="line">    &#123;</div><div class="line">        _events = new List&lt;Event&gt;();</div><div class="line">        _mementos = new List&lt;BaseMemento&gt;();</div><div class="line">        _eventBus = eventBus;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public IEnumerable&lt;Event&gt; GetEvents(Guid aggregateId)</div><div class="line">    &#123;</div><div class="line">        var events = _events.Where(p =&gt; p.AggregateId == aggregateId).Select(p =&gt; p);</div><div class="line">        if (events.Count() == 0)</div><div class="line">        &#123;</div><div class="line">            throw new AggregateNotFoundException(string.Format(&quot;Aggregate with Id: &#123;0&#125; was not found&quot;, aggregateId));</div><div class="line">        &#125;</div><div class="line">        return events;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void Save(AggregateRoot aggregate)</div><div class="line">    &#123;</div><div class="line">        var uncommittedChanges = aggregate.GetUncommittedChanges();</div><div class="line">        var version = aggregate.Version; </div><div class="line">        foreach (var @event in uncommittedChanges)</div><div class="line">        &#123;</div><div class="line">            version++;</div><div class="line">            if (version &gt; 2)</div><div class="line">            &#123;</div><div class="line">                if (version % 3 == 0)</div><div class="line">                &#123;</div><div class="line">                    var originator = (IOriginator)aggregate;</div><div class="line">                    var memento = originator.GetMemento();</div><div class="line">                    memento.Version = version;</div><div class="line">                    SaveMemento(memento);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            @event.Version=version;</div><div class="line">            _events.Add(@event);</div><div class="line">        &#125;</div><div class="line">        foreach (var @event in uncommittedChanges)</div><div class="line">        &#123;</div><div class="line">            var desEvent = Converter.ChangeTo(@event, @event.GetType());</div><div class="line">            _eventBus.Publish(desEvent);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public T GetMemento&lt;T&gt;(Guid aggregateId) where T : BaseMemento</div><div class="line">    &#123;</div><div class="line">        var memento = _mementos.Where(m =&gt; m.Id == aggregateId).Select(m=&gt;m).LastOrDefault();</div><div class="line">        if (memento != null)</div><div class="line">            return (T) memento;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void SaveMemento(BaseMemento memento)</div><div class="line">    &#123;</div><div class="line">        _mementos.Add(memento);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在GetEvent方法中，会找到所有的聚合根Id相关的事件。在Save方法中，将所有的事件保存在内存中，然后每隔三个事件建立一个快照。可以看到这里面使用了备忘录模式。</p>
<p>然后在foreach循环中，对于所有的没有提交的变更，EventBus将该事件发布出去。</p>
<p>现在，所有的发生变更的事件已经记录下来了。事件已经被发布到EventBus上，然后对应的EventHandler再处理对应的事件，然后与DB交互。现在来看EventBus的Publish方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class EventBus:IEventBus</div><div class="line">&#123;</div><div class="line">    private IEventHandlerFactory _eventHandlerFactory;</div><div class="line"></div><div class="line">    public EventBus(IEventHandlerFactory eventHandlerFactory)</div><div class="line">    &#123;</div><div class="line">        _eventHandlerFactory = eventHandlerFactory;</div><div class="line">    &#125; </div><div class="line">    public void Publish&lt;T&gt;(T @event) where T : Event</div><div class="line">    &#123;</div><div class="line">        var handlers = _eventHandlerFactory.GetHandlers&lt;T&gt;();</div><div class="line">        foreach (var eventHandler in handlers)</div><div class="line">        &#123;</div><div class="line">            eventHandler.Handle(@event);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到EventBus的Publish和CommandBus中的Send方法很相似，都是首先通过EventHandlerFactory查找对应Event的Handler，然后调用其Handler方法。比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class StructureMapEventHandlerFactory : IEventHandlerFactory</div><div class="line">&#123;</div><div class="line">    public IEnumerable&lt;IEventHandler&lt;T&gt;&gt; GetHandlers&lt;T&gt;() where T : Event</div><div class="line">    &#123;</div><div class="line">        var handlers = GetHandlerType&lt;T&gt;(); </div><div class="line">        var lstHandlers = handlers.Select(handler =&gt; (IEventHandler&lt;T&gt;) ObjectFactory.GetInstance(handler)).ToList();</div><div class="line">        return lstHandlers;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static IEnumerable&lt;Type&gt; GetHandlerType&lt;T&gt;() where T : Event</div><div class="line">    &#123; </div><div class="line">        var handlers = typeof(IEventHandler&lt;&gt;).Assembly.GetExportedTypes()</div><div class="line">            .Where(x =&gt; x.GetInterfaces()</div><div class="line">                .Any(a =&gt; a.IsGenericType &amp;&amp; a.GetGenericTypeDefinition() == typeof(IEventHandler&lt;&gt;)))</div><div class="line">                .Where(h =&gt; h.GetInterfaces()</div><div class="line">                    .Any(ii =&gt; ii.GetGenericArguments()</div><div class="line">                        .Any(aa =&gt; aa == typeof(T))))</div><div class="line">                 .ToList();</div><div class="line">        return handlers;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后返回并实例化了ItemCreatedEventHandler 对象，该对象的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public class ItemCreatedEventHandler : IEventHandler&lt;ItemCreatedEvent&gt;</div><div class="line">&#123;</div><div class="line">    private readonly IReportDatabase _reportDatabase;</div><div class="line">    public ItemCreatedEventHandler(IReportDatabase reportDatabase)</div><div class="line">    &#123;</div><div class="line">        _reportDatabase = reportDatabase;</div><div class="line">    &#125;</div><div class="line">    public void Handle(ItemCreatedEvent handle)</div><div class="line">    &#123;</div><div class="line">        DiaryItemDto item = new DiaryItemDto()</div><div class="line">            &#123;</div><div class="line">                Id = handle.AggregateId,</div><div class="line">                Description =  handle.Description,</div><div class="line">                From = handle.From,</div><div class="line">                Title = handle.Title,</div><div class="line">                To=handle.To,</div><div class="line">                Version =  handle.Version</div><div class="line">            &#125;;</div><div class="line"></div><div class="line">        _reportDatabase.Add(item);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到在Handler方法中，从事件中获取参数，然后新建DTO对象，然后将该对象更新到DB中。</p>
<p>到此，整个Command执行完成。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>CQRS是一种思想很简单清晰的设计模式，他通过在业务上分离操作和查询来使得系统具有更好的可扩展性及性能，使得能够对系统的不同部分进行扩展和优化。在CQRS中，所有的涉及到对DB的操作都是通过发送Command，然后特定的Command触发对应事件来完成操作，这个过程是异步的，并且所有涉及到对系统的变更行为都包含在具体的事件中，结合Eventing Source模式，可以记录下所有的事件，而不是以往的某一点的数据信息，这些信息可以作为系统的操作日志，可以来对系统进行回退或者重放。</p>
<p>参考文章：<br>    <a href="https://www.codeproject.com/Articles/555855/Introduction-to-CQRS" target="_blank" rel="external">Introduction to CQRS</a>。<br>    <a href="http://www.cnblogs.com/yangecnu/p/Introduction-CQRS.html" target="_blank" rel="external">浅谈命令查询职责分离(CQRS)模式</a>。 </p>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2017-05-09T01:05:45.000Z" itemprop="dateUpdated">2017-05-09 09:05:45</time>
</span><br>


        
        原始链接：<a href="/2017/05/08/命令查询职责分离-CQRS-模式/" target="_blank" rel="external">http://coderpreacher.top/2017/05/08/命令查询职责分离-CQRS-模式/</a>
        
    </div>
    <footer>
        <a href="http://coderpreacher.top">
            <img src="/images/me.jpg" alt="谢晖">
            谢晖
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CQRS/">CQRS</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://coderpreacher.top/2017/05/08/命令查询职责分离-CQRS-模式/&title=《命令查询职责分离(CQRS)模式》 — coderPreacher's Blog&pic=http://coderpreacher.top/images/me.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://coderpreacher.top/2017/05/08/命令查询职责分离-CQRS-模式/&title=《命令查询职责分离(CQRS)模式》 — coderPreacher's Blog&source=Love life, love technology, positive, optimistic, beyond the self" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://coderpreacher.top/2017/05/08/命令查询职责分离-CQRS-模式/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《命令查询职责分离(CQRS)模式》 — coderPreacher's Blog&url=http://coderpreacher.top/2017/05/08/命令查询职责分离-CQRS-模式/&via=http://coderpreacher.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://coderpreacher.top/2017/05/08/命令查询职责分离-CQRS-模式/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/05/07/Nginx-基本配置与参数说明/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Nginx 基本配置与参数说明</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/05/09/领域驱动设计-DDD-Domain-Driven-Design/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">领域驱动设计(DDD:Domain-Driven Design)</h4>
      </a>
    </div>
  
</nav>



    


<section class="comments" id="comments">
    <div id="disqus_thread"></div>
    <script>
    var disqus_shortname = 'true';
    lazyScripts.push('//' + disqus_shortname + '.disqus.com/embed.js')
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>













</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechatpay.JPG" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/images/wechatpay.JPG" data-alipay="/images/alipay.JPG">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>谢晖 &copy; 2015 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://coderpreacher.top/2017/05/08/命令查询职责分离-CQRS-模式/&title=《命令查询职责分离(CQRS)模式》 — coderPreacher's Blog&pic=http://coderpreacher.top/images/me.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://coderpreacher.top/2017/05/08/命令查询职责分离-CQRS-模式/&title=《命令查询职责分离(CQRS)模式》 — coderPreacher's Blog&source=Love life, love technology, positive, optimistic, beyond the self" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://coderpreacher.top/2017/05/08/命令查询职责分离-CQRS-模式/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《命令查询职责分离(CQRS)模式》 — coderPreacher's Blog&url=http://coderpreacher.top/2017/05/08/命令查询职责分离-CQRS-模式/&via=http://coderpreacher.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://coderpreacher.top/2017/05/08/命令查询职责分离-CQRS-模式/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACwElEQVR42u3aQW7jMBAEwPz/0w6w1wWt7iEZJ0DpJNgOxVIADdXDr6/4eP073n++Ol/9VfL7fMytAw8PD2809dWxGvr/b2//B1ZXXM0ZDw8P7zavnVby7ew2zcZZfo6Hh4f3Ud6pRfB7ZHJFPDw8vL/Cay88Kwmz0fDw8PB+npeEEasX/p1fthnsxawFDw8PL+bNItTPnl/s7+Hh4eFtdNXbx26yBH//iJ+NsxwfDw8P7wIvafy3jfxTReX9aEXBwMPDwzvK2ykMSZu/baG1UcjDDcXDw8O7xksu0JaE5PNkyb4VMePh4eFd5rUP4rOP/vam1Hsi8PDw8A7x2ofvbIptgUm2HRQRBh4eHt41Xr7hqS0D+aarPMAtigceHh7eUV77CM7jgLYLNwsmHtpjeHh4eBd4beO/XV63jf98SZ3cLDw8PLzbvFlDaxbg7ky3DZfx8PDwzvLa1/5ZkWjPkwZbFAHj4eHhXePtM/LbVCyFy9vx8K6Ah4eHd4jXhrb7C9/ZmHlcgoeHh/cbeO1weQqSn7cB8cPOCDw8PLwNXv16X04639S1v/2r+Ifi4eHhHeLtXKBtpM22F9RRBR4eHt4F3s62gLyotO2xfEtBVIrw8PDwjvLapfB+ZDAbvw2d69QEDw8PL+btb59K2lr5gjhvxdUBNB4eHt4FXruMzhtjs+1W7XK/KEt4eHh427xXfLSP4Lyo5MUg/w0eHh7ebV4eBwz3dsVbFnauvkyp8fDw8A7xXuXRRgA7oUZ7Ux52RuDh4eEd4s0qyWwqeQFIfjlsg+Hh4eEd4rXFoG1uJQHxDuDhduPh4eFd491oaOWh8OF8BQ8PD+9X8mbhbL5Mbxtgy2vh4eHhfZQ322SQJyKzaONhBDw8PLxrvCSMaCeUt8dmmGJJjYeHh3eUt/Oqny9826V5u9Qedvbw8PDwOt431Z/aT2xq4+MAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
