<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Stream,Node.js Stream,Node," />





  <link rel="alternate" href="/atom.xml" title="coderPreacher's Blog" type="application/atom+xml" />






<meta name="description" content="介绍Node.js Streams具有很强大的优势：您可以使用异步的方式处理输入和输出，您可以独立的步骤转换数据。在本教程中，我将引导您完成理论，并教您如何使用对象流变换，就像Gulp一样。 什么是流？流是数据集合，就像数组或字符串一样。 不同之处在于流可能并非全部可用，并且它们不必适应内存。 这使得当处理大量数据时，流非常强大，或者一次来自外部源的数据。然而，流不仅仅是关于使用大数据。 他们也">
<meta name="keywords" content="Stream,Node.js Stream,Node">
<meta property="og:type" content="article">
<meta property="og:title" content="你必须知道的Node.js Stream">
<meta property="og:url" content="http://coderpreacher.top/2017/09/09/你必须知道的Node-js-Stream/index.html">
<meta property="og:site_name" content="coderPreacher's Blog">
<meta property="og:description" content="介绍Node.js Streams具有很强大的优势：您可以使用异步的方式处理输入和输出，您可以独立的步骤转换数据。在本教程中，我将引导您完成理论，并教您如何使用对象流变换，就像Gulp一样。 什么是流？流是数据集合，就像数组或字符串一样。 不同之处在于流可能并非全部可用，并且它们不必适应内存。 这使得当处理大量数据时，流非常强大，或者一次来自外部源的数据。然而，流不仅仅是关于使用大数据。 他们也">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/2000/1*xGNVMFqXXTeK7ZyK2eN21Q.jpeg">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/800/1*Fp3dyVZckIUjPFOp58x-zQ.png">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/800/1*lhOvZiDrVbzF8_l8QX3ACw.png">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/800/1*HGXpeiF5-hJrOk_8tT2jFA.png">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/800/1*HI-mtispQ13qm8ib5yey3g.png">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/800/1*u2kQzUD0ruPpt-xx0UOHoA.png">
<meta property="og:updated_time" content="2017-09-10T01:49:48.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="你必须知道的Node.js Stream">
<meta name="twitter:description" content="介绍Node.js Streams具有很强大的优势：您可以使用异步的方式处理输入和输出，您可以独立的步骤转换数据。在本教程中，我将引导您完成理论，并教您如何使用对象流变换，就像Gulp一样。 什么是流？流是数据集合，就像数组或字符串一样。 不同之处在于流可能并非全部可用，并且它们不必适应内存。 这使得当处理大量数据时，流非常强大，或者一次来自外部源的数据。然而，流不仅仅是关于使用大数据。 他们也">
<meta name="twitter:image" content="https://cdn-images-1.medium.com/max/2000/1*xGNVMFqXXTeK7ZyK2eN21Q.jpeg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://coderpreacher.top/2017/09/09/你必须知道的Node-js-Stream/"/>





  <title>你必须知道的Node.js Stream | coderPreacher's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">coderPreacher's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Love life, love technology, positive, optimistic, beyond the self</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://coderpreacher.top/2017/09/09/你必须知道的Node-js-Stream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="谢晖">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="coderPreacher's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">你必须知道的Node.js Stream</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-09T22:11:50+08:00">
                2017-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Node-js/" itemprop="url" rel="index">
                    <span itemprop="name">Node.js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://cdn-images-1.medium.com/max/2000/1*xGNVMFqXXTeK7ZyK2eN21Q.jpeg" alt="Streami-"></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Node.js Streams具有很强大的优势：您可以使用异步的方式处理输入和输出，您可以独立的步骤转换数据。在本教程中，我将引导您完成理论，并教您如何使用对象流变换，就像Gulp一样。</p>
<h1 id="什么是流？"><a href="#什么是流？" class="headerlink" title="什么是流？"></a>什么是流？</h1><p>流是数据集合，就像数组或字符串一样。 不同之处在于流可能并非全部可用，并且它们不必适应内存。 这使得当处理大量数据时，流非常强大，或者一次来自外部源的数据。<br>然而，流不仅仅是关于使用大数据。 他们也给我们在我们的代码中组合的力量。 就像我们可以通过管道其他较小的Linux命令组成强大的linux命令一样，我们可以在Node中使用流完全一样。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*Fp3dyVZckIUjPFOp58x-zQ.png" alt="stream"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const grep = ... // A stream for the grep output</div><div class="line">const wc = ... // A stream for the wc input</div><div class="line">grep.pipe(wc)</div></pre></td></tr></table></figure>
<p>Node中的许多内置模块实现流式接口：<br><img src="https://cdn-images-1.medium.com/max/800/1*lhOvZiDrVbzF8_l8QX3ACw.png" alt="node stream module"></p>
<p>上面的列表有一些本机Node.js对象的示例，这些对象也是可读写的流。 这些对象中的一些是可读写的流，如TCP套接字，<code>zlib</code>和<code>crypto</code>流。<br>注意对象也是密切相关的。 虽然HTTP响应是客户端上的可读流，但它是服务器上的可写入流。 这是因为在HTTP情况下，我们基本上从一个对象（<code>http.IncomingMessage</code>）读取并写入另一个对象（<code>http.ServerResponse</code>）。<br>还要注意，当涉及到子进程时，stdio stream（stdin，stdout，stderr）如何具有逆流类型。 这允许一种非常简单的方式来管理来自主进程stdio流的这些流。</p>
<h1 id="您的第一流应用程序"><a href="#您的第一流应用程序" class="headerlink" title="您的第一流应用程序"></a>您的第一流应用程序</h1><p>我们来仔细看看流。 为此，我们将构建一个简单的文件上传应用程序。 首先，我们需要构建一个使用可读流读取文件并将数据管理到特定目标的客户端。 在管道的另一端，我们将实现一个使用可写入流保存上传数据的服务器。</p>
<p>我们从客户端开始吧。 我们从导入HTTP和文件系统模块开始。</p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var http = require(&apos;http&apos;)</div><div class="line">  , fs = require(&apos;fs&apos;);</div></pre></td></tr></table></figure>
<p>然后，我们定义我们的HTTP请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var options = &#123;</div><div class="line">  host: &apos;localhost&apos;</div><div class="line">  , port: 8000</div><div class="line">  , path: &apos;/&apos;</div><div class="line">  , method: &apos;POST&apos;</div><div class="line">&#125;;</div><div class="line">var req = http.request(options, function(res) &#123;</div><div class="line">  console.log(res.statusCode);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>现在我们有了我们的请求，我们创建一个读取文件并将内容管理到请求对象的可读流。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var readStream = fs.ReadStream(__dirname + &amp;quot;/in.txt&amp;quot;);</div><div class="line">readStream.pipe(req);</div></pre></td></tr></table></figure>
<p>一旦流完成读取所有数据，我们关闭与服务器的连接，调用我们的请求的<code>end()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">readStream.on(&apos;close&apos;, function () &#123;</div><div class="line">  req.end();</div><div class="line">  console.log(&amp;quot;I finished.&amp;quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>就像我们为客户端所做的那样，我们从导入Node.js模块开始。然后，我们创建一个新的可写流，将数据保存到文本文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var http = require(&apos;http&apos;)</div><div class="line">  , fs = require(&apos;fs&apos;);</div><div class="line"></div><div class="line">var writeStream = fs.createWriteStream(__dirname + &amp;quot;/out.txt&amp;quot;);</div></pre></td></tr></table></figure>
<p>为了让我们的客户端应用上传文件，我们必须创建一个新的Web服务器对象。当数据来自请求对象时，服务器调用我们的流并将缓冲区刷新到输出文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var server = http.createServer(function (req, res) &#123;</div><div class="line">  req.on(&apos;data&apos;, function (data) &#123;</div><div class="line">    writeStream.write(data);</div><div class="line">  &#125;);</div><div class="line">  req.on(&apos;end&apos;, function() &#123;</div><div class="line">    writeStream.end();</div><div class="line">    res.statusCode = 200;</div><div class="line">    res.end(&amp;quot;OK&amp;quot;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line">server.listen(8000);</div></pre></td></tr></table></figure>
<p>请注意，<code>createServer（）</code>返回的<code>req</code>和<code>res</code>对象分别是可读流和可写入流。我们可以监听数据事件，并且一旦处理结束，就将结果回送给客户端。</p>
<h1 id="Node-js中的Stream"><a href="#Node-js中的Stream" class="headerlink" title="Node.js中的Stream"></a>Node.js中的Stream</h1><p>Node.js中有四种基本流类型：<code>Readable</code>（可读），<code>Writable</code>（可写），<code>Duplex</code>（双工）和<code>Transform</code>（转换）。</p>
<ul>
<li><code>Readable</code>可读流是可以从其中消耗数据的源的抽象。一个例子是<code>fs.createReadStream</code>方法。</li>
<li><code>Writable</code>可写流是可以写入数据的目的地的抽象。一个例子是<code>fs.createWriteStream</code>方法。</li>
<li><code>Duplex</code>双工流既可读又可写。一个例子是TCP套接字。</li>
<li><code>Transform</code>变换流基本上是一个双工流，可用于在写入和读取数据时修改或转换数据。一个例子是使用<code>gzip</code>压缩数据的<code>zlib.createGzip</code>流。您可以将变换流视为函数，其中输入是可写入流部分，输出是可读流部分。您也可能会听到称为“通过流”的转换流。</li>
</ul>
<p>所有流都是<code>EventEmitter</code>的实例。它们发出可用于读取和写入数据的事件。但是，我们可以使用管道方法以更简单的方式使用流数据。</p>
<h3 id="pipe-管道-方法"><a href="#pipe-管道-方法" class="headerlink" title="pipe(管道) 方法"></a><code>pipe</code>(管道) 方法</h3><p>这是您需要记住的魔术线：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">readableSrc.pipe(writableDest)</div></pre></td></tr></table></figure>
<p>在这个简单的一行中，我们将可读流的输出（数据源）作为可写流的输入 - 目标管道。源必须是可读流，目的地必须是可写的。当然，它们也可以是双工/转换流。实际上，如果我们正在进行双工流，我们可以像在Linux中一样链接管道呼叫：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">readableSrc</div><div class="line">  .pipe(transformStream1)</div><div class="line">  .pipe(transformStream2)</div><div class="line">  .pipe(finalWrtitableDest)</div></pre></td></tr></table></figure>
<p><code>pipe</code>方法返回目标流，这使我们能够在上面进行链接。对于流（可读），b和c（双工）和d（可写），我们可以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">a.pipe(b).pipe(c).pipe(d)</div><div class="line"></div><div class="line"># Which is equivalent to:</div><div class="line">a.pipe(b)</div><div class="line">b.pipe(c)</div><div class="line">c.pipe(d)</div><div class="line"></div><div class="line"># Which, in Linux, is equivalent to:</div><div class="line">$ a | b | c | d</div></pre></td></tr></table></figure>
<p><code>pipe</code>方法是消耗流的最简单方法。通常建议使用管道方法或使用事件消耗流，但不要混合这两个。通常当您使用管道方法时，您不需要使用事件，但是如果您需要以更自定义的方式使用流，那么事件就是要走的路。</p>
<h3 id="流事件-Stream-events"><a href="#流事件-Stream-events" class="headerlink" title="流事件(Stream events)"></a>流事件(Stream events)</h3><p>除了从可读流源读取和写入可写目的地之外，管道方法还会自动管理一些事情。例如，它处理错误，文件结尾以及一个流比另一个流更慢或更快的情况。</p>
<p>但是，流也可以直接与事件一起使用。以下是管道方法主要用于读取和写入数据的简化事件等效代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># readable.pipe(writable)</div><div class="line">readable.on(&apos;data&apos;, (chunk) =&gt; &#123;</div><div class="line">  writable.write(chunk);</div><div class="line">&#125;);</div><div class="line">readable.on(&apos;end&apos;, () =&gt; &#123;</div><div class="line">  writable.end();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>以下是可读写可用流的重要事件和功能的列表：</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*HGXpeiF5-hJrOk_8tT2jFA.png" alt="流事件(Stream events)"></p>
<p>事件和功能在某种程度上是相关的，因为它们通常被一起使用。</p>
<p><code>Readable</code>可读流最重要的事件是：</p>
<ul>
<li><code>data</code>事件，当流将一大块数据传递给消费者时，该事件被发出。</li>
<li><code>end</code>事件，当没有更多数据要从流中消耗时发出。</li>
</ul>
<p><code>Writable</code>可写的流中最重要的事件是：</p>
<ul>
<li><code>drain</code>事件是可写入流可以接收更多数据的信号。</li>
<li><code>finish</code>事件，当所有数据已刷新到底层系统时都会发出。</li>
</ul>
<p>事件和功能可以组合起来，以便定制和优化流的使用。要使用可读流，我们可以使用<code>pipe/unpipe</code>方法，或者<code>read/unshift/resume</code>方法。要使用可写入流，我们可以使用<code>pipe/unpipe</code>方法，或者只是使用<code>write</code>方法写入它，并在完成后调用<code>end</code>方法。</p>
<h3 id="可读流的暂停和流动模式"><a href="#可读流的暂停和流动模式" class="headerlink" title="可读流的暂停和流动模式"></a>可读流的暂停和流动模式</h3><p>可读流具有两种主要模式，影响我们消费的方式：</p>
<ul>
<li>它们可以处于暂停模式</li>
<li>或者在流动模式</li>
</ul>
<p>这些模式有时被称为拉和推模式。 </p>
<p>默认情况下，所有可读流可在暂停模式下启动，但在需要时可以轻松切换到流动状态并返回到暂停状态。有时会自动切换。 </p>
<p>当可读流处于暂停模式时，我们可以使用<code>read</code>方法从流中读取流，但是，对于流模式中的可读流，数据持续流动，我们必须收听事件消耗它</p>
<p>在流动模式下，如果没有消费者可以处理它，数据实际上可能会丢失。这就是为什么当我们在流模式下有可读流时，我们需要一个数据事件处理程序。事实上，只需添加一个数据事件处理程序即可将暂停的流转换为流模式，并删除数据事件处理程序将流切换回暂停模式。其中一些是为了与旧的<code>Node Stream</code>接口的向后兼容而完成的。 </p>
<p>要手动切换这两种流模式，可以使用<code>resume</code>和<code>pause</code>方法。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*HI-mtispQ13qm8ib5yey3g.png" alt="Readable Streams"></p>
<p>当使用管道方法消耗可读流时，我们不必担心管道自动管理这些模式。</p>
<h1 id="流实现"><a href="#流实现" class="headerlink" title="流实现"></a>流实现</h1><p>当谈到Node.js中的流时，主要有两个不同的任务：</p>
<ul>
<li>实现流的任务。 </li>
<li>消费它们的任务。 </li>
</ul>
<p>到目前为止，我们一直在谈论只消耗流。让我们实现一些！</p>
<h3 id="实现可写流-Writable"><a href="#实现可写流-Writable" class="headerlink" title="实现可写流(Writable)"></a>实现可写流(Writable)</h3><p>要实现可写流，我们需要使用<code>Stream</code>模块中的<code>Writable</code>构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const &#123; Writable &#125; = require(&apos;stream&apos;);</div></pre></td></tr></table></figure>
<p>我们可以在许多方面实现一个可写的流。例如，我们可以扩展<code>Writable</code>构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class myWritableStream extends Writable &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是，我更喜欢更简单的构造方法。我们只是从<code>Writable</code>构造函数创建一个对象，并传递一些选项。唯一需要的选项是<code>write</code>函数，它暴露要写入的数据块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">const &#123; Writable &#125; = require(&apos;stream&apos;);</div><div class="line">const outStream = new Writable(&#123;</div><div class="line">  write(chunk, encoding, callback) &#123;</div><div class="line">    console.log(chunk.toString());</div><div class="line">    callback();</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">process.stdin.pipe(outStream);</div></pre></td></tr></table></figure>
<p>这个写入方法有三个参数。</p>
<ul>
<li>除非我们以不同的方式配置流，否则<code>chunk</code>(块)通常是缓冲区。</li>
<li>在这种情况下需要<code>encoding</code>(编码参数)，但通常我们可以忽略它。</li>
<li><code>callback</code>回调函数是处理数据块后我们需要调用的函数。这是写信是否成功的信号。要发出失败信号，请使用错误对象调用回调。</li>
</ul>
<p>在<code>outStream</code>中，我们只是将该块作为一个字符串进行<code>console.log</code>，然后在没有错误的情况下调用回调来表示成功。这是一个非常简单的，可能不是很有用的回声流。它将回传任何收到的东西。</p>
<p>要消耗这个流，我们可以简单地使用<code>process.stdin</code>，这是一个可读的流，所以我们可以将<code>process.stdin</code>管道传入我们的<code>outstream</code></p>
<p>当我们运行上面的代码时，我们输入到<code>process.stdin</code>的任何东西都将使用<code>outStream</code> <code>console.log</code>行回显。</p>
<p>这不是一个非常有用的实现流，因为它实际上已经被实现和内置。这非常等同于process.stdout。我们可以将stdin管道输入stdout，我们可以用这条单行得到完全相同的回声功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">process.stdin.pipe(process.stdout);</div></pre></td></tr></table></figure>
<h3 id="实现可读流-Readable"><a href="#实现可读流-Readable" class="headerlink" title="实现可读流(Readable)"></a>实现可读流(Readable)</h3><p>要实现可读流，我们需要可读接口并从中构造一个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const &#123; Readable &#125; = require(&apos;stream&apos;);</div><div class="line">const inStream = new Readable(&#123;&#125;);</div></pre></td></tr></table></figure>
<p>有一种实现可读流的简单方法。我们可以直接<code>push</code>(推送)我们希望消费者消费的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const &#123; Readable &#125; = require(&apos;stream&apos;); </div><div class="line">const inStream = new Readable();</div><div class="line">inStream.push(&apos;ABCDEFGHIJKLM&apos;);</div><div class="line">inStream.push(&apos;NOPQRSTUVWXYZ&apos;);</div><div class="line">inStream.push(null); // No more data</div><div class="line">inStream.pipe(process.stdout);</div></pre></td></tr></table></figure>
<p>当我们<code>push</code>一个空对象时，这意味着我们想要表示流没有任何更多的数据。</p>
<p>为了消耗这个简单的可读流，我们可以简单地将它导入到可写入流<code>process.stdout</code>中。</p>
<p>当我们运行上面的代码时，我们将从<code>inStream</code>读取所有数据，并将其回显到标准。很简单，也不是很有效率。</p>
<p>我们基本上推送流中的所有数据，然后将其管理到<code>process.stdout</code>。更好的方法是在消费者要求时按需推送数据。我们可以通过在可读流配置中实现<code>read</code>方法来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const inStream = new Readable(&#123;</div><div class="line">  read(size) &#123;</div><div class="line">    // there is a demand on the data... Someone wants to read it.</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当读取方法在可读流上被调用时，该实现可以将部分数据推送到队列。例如，我们可以一次推一个字母，从字符代码65（表示A）开始，并在每次推送时递增：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const inStream = new Readable(&#123;</div><div class="line">  read(size) &#123;</div><div class="line">    this.push(String.fromCharCode(this.currentCharCode++));</div><div class="line">    if (this.currentCharCode &gt; 90) &#123;</div><div class="line">      this.push(null);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">inStream.currentCharCode = 65;</div><div class="line">inStream.pipe(process.stdout);</div></pre></td></tr></table></figure>
<p>当消费者读取可读流时，读取方法将继续触发，我们会推送更多的信件。我们需要在某个地方停止这个循环，这就是为什么当currentCharCode大于90（表示Z）时，if语句推空。</p>
<p>这个代码相当于我们开始使用的更简单的代码，但是现在我们正在按消费者要求的数据推送数据。你应该永远这样做.</p>
<h3 id="实现双工-Duplex-转换流-Transfer"><a href="#实现双工-Duplex-转换流-Transfer" class="headerlink" title="实现双工(Duplex)/转换流(Transfer)"></a>实现双工(Duplex)/转换流(Transfer)</h3><p>使用双工流，我们可以使用相同的对象来实现可读和可写的流。就好像我们从两个接口继承。 </p>
<p>这是一个实例双工流，它结合了上面实现的两个可写和可读的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">const &#123; Duplex &#125; = require(&apos;stream&apos;);</div><div class="line"></div><div class="line">const inoutStream = new Duplex(&#123;</div><div class="line">  write(chunk, encoding, callback) &#123;</div><div class="line">    console.log(chunk.toString());</div><div class="line">    callback();</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  read(size) &#123;</div><div class="line">    this.push(String.fromCharCode(this.currentCharCode++));</div><div class="line">    if (this.currentCharCode &gt; 90) &#123;</div><div class="line">      this.push(null);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">inoutStream.currentCharCode = 65;</div><div class="line">process.stdin.pipe(inoutStream).pipe(process.stdout);</div></pre></td></tr></table></figure>
<p>通过组合这些方法，我们可以使用这个双工流来读取从A到Z的字母，我们也可以用它的回波特征。我们将可读的stdin流管道到这个双工流中以使用回声功能，我们将双工流本身管道写入可写入<code>stdout</code>流，以查看字母A到Z。</p>
<p>重要的是要了解双工流的可读写双方完全独立运行。这只是将两个特征组合成一个对象。</p>
<p>转换流是更有趣的双工流，因为它的输出是从其输入计算的。</p>
<p>对于一个转换流，我们不需要实现读取或者写入方法，我们只需要实现一个转换方法，它将两者结合起来。它具有写入方式的签名，我们也可以使用它来推送数据。</p>
<p>这是一个简单的转换流，它将您将其转换为大写格式后，再次输入任何内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const &#123; Transform &#125; = require(&apos;stream&apos;);</div><div class="line"></div><div class="line">const upperCaseTr = new Transform(&#123;</div><div class="line">  transform(chunk, encoding, callback) &#123;</div><div class="line">    this.push(chunk.toString().toUpperCase());</div><div class="line">    callback();</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">process.stdin.pipe(upperCaseTr).pipe(process.stdout);</div></pre></td></tr></table></figure>
<p>在这个转换流中，我们正在消费与之前的双工流示例一样，我们只实现了一个<code>transform</code>方法。在该方法中，我们将块转换为大写版本，然后将该版本推送为可读部分。</p>
<h3 id="流对象模式-Stream-Object-Mode"><a href="#流对象模式-Stream-Object-Mode" class="headerlink" title="流对象模式(Stream Object Mode)"></a>流对象模式(Stream Object Mode)</h3><p>默认情况下，流期望缓冲区(Buffer)/字符串(String)值。有一个<code>objectMode</code>标志，我们可以设置为让流接受任何JavaScript对象。</p>
<p>这是一个简单的例子来证明这一点。以下变换流的组合使得将逗号分隔值的字符串映射为JavaScript对象的功能。所以“a，b，c，d”成为{a：b，c：d}。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">const &#123; Transform &#125; = require(&apos;stream&apos;);</div><div class="line">const commaSplitter = new Transform(&#123;</div><div class="line">  readableObjectMode: true,</div><div class="line">  transform(chunk, encoding, callback) &#123;</div><div class="line">    this.push(chunk.toString().trim().split(&apos;,&apos;));</div><div class="line">    callback();</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">const arrayToObject = new Transform(&#123;</div><div class="line">  readableObjectMode: true,</div><div class="line">  writableObjectMode: true,</div><div class="line">  transform(chunk, encoding, callback) &#123;</div><div class="line">    const obj = &#123;&#125;;</div><div class="line">    for(let i=0; i &lt; chunk.length; i+=2) &#123;</div><div class="line">      obj[chunk[i]] = chunk[i+1];</div><div class="line">    &#125;</div><div class="line">    this.push(obj);</div><div class="line">    callback();</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">const objectToString = new Transform(&#123;</div><div class="line">  writableObjectMode: true,</div><div class="line">  transform(chunk, encoding, callback) &#123;</div><div class="line">    this.push(JSON.stringify(chunk) + &apos;\n&apos;);</div><div class="line">    callback();</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">process.stdin</div><div class="line">  .pipe(commaSplitter)</div><div class="line">  .pipe(arrayToObject)</div><div class="line">  .pipe(objectToString)</div><div class="line">  .pipe(process.stdout)</div></pre></td></tr></table></figure>
<p>我们通过commasplitter传递输入字符串（例如“a，b，c，d”），该数组将数组作为其可读取数据（[“a”，“b”，“c”，“d”]））。在该流上添加可读ObjectMode标志是必要的，因为我们正在将对象推送到其上，而不是字符串。</p>
<p>然后我们将数组并且将其导入到arrayToObject流中。我们需要一个writableObjectMode标志来使该流接受一个对象。它还将推送一个对象（输入数组映射到一个对象），这就是为什么我们也需要可读ObjectMode标志的原因。最后一个objectToString流接受一个对象，但是推出一个字符串，这就是为什么我们只需要一个writableObjectMode标志的原因。可读部分是普通字符串（字符串对象）。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*u2kQzUD0ruPpt-xx0UOHoA.png" alt="abcd"></p>
<h3 id="Node-js内置的转换流"><a href="#Node-js内置的转换流" class="headerlink" title="Node.js内置的转换流"></a>Node.js内置的转换流</h3><p>Node有一些非常有用的内置变换流。即，<code>zlib</code>和<code>crypto</code> stream。</p>
<p>这是一个使用<code>zlib.createGzip</code>（）流结合<code>fs</code>  <code>readable/writable</code> 流创建文件压缩脚本的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">const fs = require(&apos;fs&apos;);</div><div class="line">const zlib = require(&apos;zlib&apos;);</div><div class="line">const file = process.argv[2];</div><div class="line"></div><div class="line">fs.createReadStream(file)</div><div class="line">  .pipe(zlib.createGzip())</div><div class="line">  .pipe(fs.createWriteStream(file + &apos;.gz&apos;));</div></pre></td></tr></table></figure>
<p>您可以使用此脚本将您传递的任何文件gzip作为参数。我们将该文件的可读流管道转换为zlib内置的转换流，然后转换为新的<code>gzip</code>-压缩文件的可写流。简单。</p>
<p>使用管道的很酷的事情是，如果我们需要，我们可以将它们与事件结合起来。例如，我希望用户在脚本运行时看到一个进度指示符，当脚本完成时，我想要一个“完成”消息。由于管道方法返回目标流，因此我们可以链接注册事件处理程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const fs = require(&apos;fs&apos;);</div><div class="line">const zlib = require(&apos;zlib&apos;);</div><div class="line">const file = process.argv[2];</div><div class="line"></div><div class="line">fs.createReadStream(file)</div><div class="line">  .pipe(zlib.createGzip())</div><div class="line">  .on(&apos;data&apos;, () =&gt; process.stdout.write(&apos;.&apos;))</div><div class="line">  .pipe(fs.createWriteStream(file + &apos;.zz&apos;))</div><div class="line">  .on(&apos;finish&apos;, () =&gt; console.log(&apos;Done&apos;));</div></pre></td></tr></table></figure>
<p>所以使用管道方法，我们可以轻松地消耗流，但是我们还可以使用需要的事件进一步定制与这些流的交互。 </p>
<p>管道方法有什么好处，但是我们可以使用它以一种可读的方式逐个构成我们的程序。例如，我们可以简单地创建一个变换流来报告进度，而不用监听上面的数据事件，并用另一个.pipe（）调用替换.on（）调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const fs = require(&apos;fs&apos;);</div><div class="line">const zlib = require(&apos;zlib&apos;);</div><div class="line">const file = process.argv[2];</div><div class="line"></div><div class="line">const &#123; Transform &#125; = require(&apos;stream&apos;);</div><div class="line"></div><div class="line">const reportProgress = new Transform(&#123;</div><div class="line">  transform(chunk, encoding, callback) &#123;</div><div class="line">    process.stdout.write(&apos;.&apos;);</div><div class="line">    callback(null, chunk);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">fs.createReadStream(file)</div><div class="line">  .pipe(zlib.createGzip())</div><div class="line">  .pipe(reportProgress)</div><div class="line">  .pipe(fs.createWriteStream(file + &apos;.zz&apos;))</div><div class="line">  .on(&apos;finish&apos;, () =&gt; console.log(&apos;Done&apos;));</div></pre></td></tr></table></figure>
<p>该reportProgress流是一个简单的直通流，但它将进度标准化。注意我如何使用callback（）函数中的第二个参数来推送transform（）方法中的数据。这相当于推动数据。 </p>
<p>结合流的应用是无止境的。例如，如果我们需要在我们gzip之前或之后加密文件，我们需要做的就是按照我们需要的确切顺序来管理另一个转换流。我们可以使用Node的加密模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const crypto = require(&apos;crypto&apos;);</div><div class="line">// ...</div><div class="line">fs.createReadStream(file)</div><div class="line">  .pipe(zlib.createGzip())</div><div class="line">  .pipe(crypto.createCipher(&apos;aes192&apos;, &apos;a_secret&apos;))</div><div class="line">  .pipe(reportProgress)</div><div class="line">  .pipe(fs.createWriteStream(file + &apos;.zz&apos;))</div><div class="line">  .on(&apos;finish&apos;, () =&gt; console.log(&apos;Done&apos;));</div></pre></td></tr></table></figure>
<p>上面的脚本压缩然后加密传递的文件，只有具有秘密的人可以使用输出的文件。我们无法使用正常的解压缩实用程序解压缩此文件，因为它已加密。 </p>
<p>为了能够解压缩上面脚本压缩的任何东西，我们需要以相反的顺序使用相反的加密和zlib流，这很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fs.createReadStream(file)</div><div class="line">  .pipe(crypto.createDecipher(&apos;aes192&apos;, &apos;a_secret&apos;))</div><div class="line">  .pipe(zlib.createGunzip())</div><div class="line">  .pipe(reportProgress)</div><div class="line">  .pipe(fs.createWriteStream(file.slice(0, -3)))</div><div class="line">  .on(&apos;finish&apos;, () =&gt; console.log(&apos;Done&apos;));</div></pre></td></tr></table></figure>
<p>假设传递的文件是压缩版本，上面的代码将创建一个从它的读取流，将其传输到crypto createDecipher（）流（使用相同的密钥），将其输出管道输入到zlib createGunzip（）流中，然后将文件写回到没有扩展部分的文件中。 </p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>了解了这些 Stream 的内部机制，对我们后续深入理解上层代码有很大的促进作用，特别希望初学 Node.js 的同学花点时间进来看看。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Stream/" rel="tag"># Stream</a>
          
            <a href="/tags/Node-js-Stream/" rel="tag"># Node.js Stream</a>
          
            <a href="/tags/Node/" rel="tag"># Node</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/10/可扩展的Node-js应用/" rel="next" title="可扩展的Node.js应用">
                <i class="fa fa-chevron-left"></i> 可扩展的Node.js应用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/07/31/了解Node-js事件循环/" rel="prev" title="了解Node.js事件循环">
                了解Node.js事件循环 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">谢晖</p>
              <p class="site-description motion-element" itemprop="description">Love life, love technology, positive, optimistic, beyond the self</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">65</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#介绍"><span class="nav-number">1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是流？"><span class="nav-number">2.</span> <span class="nav-text">什么是流？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#您的第一流应用程序"><span class="nav-number">3.</span> <span class="nav-text">您的第一流应用程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#客户端"><span class="nav-number">3.0.0.1.</span> <span class="nav-text">客户端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#服务端"><span class="nav-number">3.0.0.2.</span> <span class="nav-text">服务端</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Node-js中的Stream"><span class="nav-number">4.</span> <span class="nav-text">Node.js中的Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pipe-管道-方法"><span class="nav-number">4.0.1.</span> <span class="nav-text">pipe(管道) 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流事件-Stream-events"><span class="nav-number">4.0.2.</span> <span class="nav-text">流事件(Stream events)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可读流的暂停和流动模式"><span class="nav-number">4.0.3.</span> <span class="nav-text">可读流的暂停和流动模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#流实现"><span class="nav-number">5.</span> <span class="nav-text">流实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现可写流-Writable"><span class="nav-number">5.0.1.</span> <span class="nav-text">实现可写流(Writable)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现可读流-Readable"><span class="nav-number">5.0.2.</span> <span class="nav-text">实现可读流(Readable)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现双工-Duplex-转换流-Transfer"><span class="nav-number">5.0.3.</span> <span class="nav-text">实现双工(Duplex)/转换流(Transfer)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流对象模式-Stream-Object-Mode"><span class="nav-number">5.0.4.</span> <span class="nav-text">流对象模式(Stream Object Mode)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-js内置的转换流"><span class="nav-number">5.0.5.</span> <span class="nav-text">Node.js内置的转换流</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#小结"><span class="nav-number">6.</span> <span class="nav-text">小结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">谢晖</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
